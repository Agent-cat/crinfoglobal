module.exports = [
"[project]/node_modules/@citation-js/plugin-bibtex/lib/mapping/biblatexTypes.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"source":{"article":"article-journal","book":"book","mvbook":"book","inbook":"chapter","bookinbook":"book","booklet":"book","collection":"book","mvcollection":"book","incollection":"chapter","dataset":"dataset","manual":"report","misc":"document","online":"webpage","patent":"patent","periodical":"periodical","proceedings":"book","mvproceedings":"book","inproceedings":"paper-conference","reference":"book","mvreference":"book","inreference":"entry","report":"report","software":"software","thesis":"thesis","unpublished":"manuscript","artwork":"graphic","audio":"song","image":"figure","jurisdiction":"legal_case","legislation":"legislation","legal":"treaty","letter":"personal_communication","movie":"motion_picture","music":"musical_score","performance":"performance","review":"review","standard":"standard","video":"motion_picture","conference":"paper-conference","electronic":"webpage","mastersthesis":"thesis","phdthesis":"thesis","techreport":"report","www":"webpage"},"target":{"article":"article","article-journal":"article","article-magazine":"article","article-newspaper":"article","bill":"legislation","book":"book","broadcast":"audio","chapter":"inbook","classic":"unpublished","collection":"misc","dataset":"dataset","document":"misc","entry":"inreference","entry-dictionary":"inreference","entry-encyclopedia":"inreference","event":"misc","figure":"artwork","graphic":"artwork","hearing":"legal","interview":"audio","legal_case":"jurisdiction","legislation":"legislation","manuscript":"unpublished","motion_picture":"movie","musical_score":"music","paper-conference":"inproceedings","patent":"patent","performance":"performance","periodical":"periodical","personal_communication":"letter","post":"online","post-weblog":"online","regulation":"legal","report":"report","review":"review","review-book":"review","software":"software","song":"music","speech":"audio","standard":"standard","thesis":"thesis","treaty":"legal","webpage":"online"}});}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib/mapping/bibtexTypes.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"source":{"article":"article-journal","book":"book","booklet":"book","conference":"paper-conference","inbook":"chapter","incollection":"chapter","inproceedings":"paper-conference","manual":"report","mastersthesis":"thesis","misc":"document","phdthesis":"thesis","proceedings":"book","techreport":"report","unpublished":"manuscript"},"target":{"article":"article","article-journal":"article","article-magazine":"article","article-newspaper":"article","book":"book","chapter":"inbook","manuscript":"unpublished","paper-conference":"inproceedings","report":"techreport","review":"article","review-book":"article"}});}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib/input/required.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"biblatex":{"article":["author","title","journaltitle",["year","date"]],"book":["author","title",["year","date"]],"mvbook":["author","title",["year","date"]],"inbook":["author","title","booktitle",["year","date"]],"booklet":[["author","editor"],"title",["year","date"]],"collection":["editor","title",["year","date"]],"mvcollection":["editor","title",["year","date"]],"incollection":["author","title","booktitle",["year","date"]],"dataset":[["author","editor"],"title",["year","date"]],"online":[["author","editor"],"title",["year","date"],["doi","eprint","url"]],"patent":["author","title","number",["year","date"]],"periodical":["editor","title",["year","date"]],"proceedings":["title",["year","date"]],"mvproceedings":["title",["year","date"]],"inproceedings":["author","title","booktitle",["year","date"]],"report":["author","title","type","institution",["year","date"]],"thesis":["author","title","type","institution",["year","date"]],"unpublished":["author","title",["year","date"]],"conference":["author","title","booktitle",["year","date"]],"electronic":[["author","editor"],"title",["year","date"],["doi","eprint","url"]],"mastersthesis":["author","title","institution",["year","date"]],"phdthesis":["author","title","institution",["year","date"]],"techreport":["author","title","institution",["year","date"]],"www":[["author","editor"],"title",["year","date"],["doi","eprint","url"]]},"bibtex":{"article":["author","title","journal","year"],"book":[["author","editor"],"title","publisher","year"],"booklet":["title"],"inbook":[["author","editor"],"title",["chapter","pages"],"publisher","year"],"incollection":["author","title","booktitle","publisher","year"],"inproceedings":["author","title","booktitle","year"],"mastersthesis":["author","title","school","year"],"phdthesis":["author","title","school","year"],"proceedings":["title","year"],"techreport":["author","title","institution","year"],"unpublished":["author","title","note"]}});}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib/input/fieldTypes.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"abstract":["field","literal"],"addendum":["field","literal"],"afterword":["list","name"],"annotation":["field","literal"],"annotator":["list","name"],"author":["list","name"],"authortype":["field","key"],"bookauthor":["list","name"],"bookpagination":["field","key"],"booksubtitle":["field","literal"],"booktitle":["field","title"],"booktitleaddon":["field","literal"],"chapter":["field","literal"],"commentator":["list","name"],"date":["field","date"],"doi":["field","verbatim"],"edition":["field","literal"],"editor":["list","name"],"editora":["list","name"],"editorb":["list","name"],"editorc":["list","name"],"editortype":["field","key"],"editoratype":["field","key"],"editorbtype":["field","key"],"editorctype":["field","key"],"eid":["field","literal"],"entrysubtype":["field","literal"],"eprint":["field","verbatim"],"eprintclass":["field","literal"],"eprinttype":["field","literal"],"eventdate":["field","date"],"eventtitle":["field","title"],"eventtitleaddon":["field","literal"],"file":["field","verbatim"],"foreword":["list","name"],"holder":["list","name"],"howpublished":["field","literal"],"indextitle":["field","literal"],"institution":["list","literal"],"introduction":["list","name"],"isan":["field","literal"],"isbn":["field","literal"],"ismn":["field","literal"],"isrn":["field","literal"],"issn":["field","literal"],"issue":["field","literal"],"issuesubtitle":["field","literal"],"issuetitle":["field","literal"],"iswc":["field","literal"],"journalsubtitle":["field","literal"],"journaltitle":["field","literal"],"label":["field","literal"],"language":["list","key"],"library":["field","literal"],"location":["list","literal"],"mainsubtitle":["field","literal"],"maintitle":["field","title"],"maintitleaddon":["field","literal"],"month":["field","literal"],"nameaddon":["field","literal"],"note":["field","literal"],"number":["field","literal"],"organization":["list","literal"],"origdate":["field","date"],"origlanguage":["list","key"],"origlocation":["list","literal"],"origpublisher":["list","literal"],"origtitle":["field","title"],"pages":["field","range"],"pagetotal":["field","literal"],"pagination":["field","key"],"part":["field","literal"],"publisher":["list","literal"],"pubstate":["field","key"],"reprinttitle":["field","literal"],"series":["field","title"],"shortauthor":["list","name"],"shorteditor":["list","name"],"shorthand":["field","literal"],"shorthandintro":["field","literal"],"shortjournal":["field","literal"],"shortseries":["field","literal"],"shorttitle":["field","title"],"subtitle":["field","literal"],"title":["field","title"],"titleaddon":["field","literal"],"translator":["list","name"],"type":["field","title"],"url":["field","uri"],"urldate":["field","date"],"venue":["field","literal"],"version":["field","literal"],"volume":["field","integer"],"volumes":["field","integer"],"year":["field","literal"],"crossref":["field","entry key"],"entryset":["separated","literal"],"execute":["field","code"],"gender":["field","gender"],"langid":["field","identifier"],"langidopts":["field","literal"],"ids":["separated","entry key"],"indexsorttitle":["field","literal"],"keywords":["separated","literal"],"options":["separated","options"],"presort":["field","string"],"related":["separated","literal"],"relatedoptions":["separated","literal"],"relatedtype":["field","identifier"],"relatedstring":["field","literal"],"sortkey":["field","literal"],"sortname":["list","name"],"sortshorthand":["field","literal"],"sorttitle":["field","literal"],"sortyear":["field","integer"],"xdata":["separated","entry key"],"xref":["field","entry key"],"namea":["list","name"],"nameb":["list","name"],"namec":["list","name"],"nameatype":["field","key"],"namebtype":["field","key"],"namectype":["field","key"],"lista":["list","literal"],"listb":["list","literal"],"listc":["list","literal"],"listd":["list","literal"],"liste":["list","literal"],"listf":["list","literal"],"usera":["field","literal"],"userb":["field","literal"],"userc":["field","literal"],"userd":["field","literal"],"usere":["field","literal"],"userf":["field","literal"],"verba":["field","literal"],"verbb":["field","literal"],"verbc":["field","literal"],"address":["list","literal"],"annote":["field","literal"],"archiveprefix":["field","literal"],"journal":["field","literal"],"key":["field","literal"],"pdf":["field","verbatim"],"primaryclass":["field","literal"],"school":["list","literal"],"numpages":["field","integer"],"pmid":["field","literal"],"pmcid":["field","literal"]});}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib/input/unicode.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"diacritics":{"`":"̀","'":"́","^":"̂","~":"̃","=":"̄","u":"̆",".":"̇","\"":"̈","r":"̊","H":"̋","v":"̌","b":"̲","d":"̣","c":"̧","k":"̨","t":"͡","textcommabelow":"̦"},"commands":{"textquotesingle":"'","textasciigrave":"`","textquotedbl":"\"","textdollar":"$","textless":"<","textgreater":">","textbackslash":"\\","textasciicircum":"^","textunderscore":"_","textbraceleft":"{","textbar":"|","textbraceright":"}","textasciitilde":"~","textexclamdown":"¡","textcent":"¢","textsterling":"£","textcurrency":"¤","textyen":"¥","textbrokenbar":"¦","textsection":"§","textasciidieresis":"¨","textcopyright":"©","textordfeminine":"ª","guillemetleft":"«","guillemotleft":"«","textlnot":"¬","textregistered":"®","textasciimacron":"¯","textdegree":"°","textpm":"±","texttwosuperior":"²","textthreesuperior":"³","textasciiacute":"´","textmu":"µ","textparagraph":"¶","textperiodcentered":"·","textonesuperior":"¹","textordmasculine":"º","guillemetright":"»","guillemotright":"»","textonequarter":"¼","textonehalf":"½","textthreequarters":"¾","textquestiondown":"¿","AE":"Æ","DH":"Ð","texttimes":"×","O":"Ø","TH":"Þ","ss":"ß","ae":"æ","dh":"ð","textdiv":"÷","o":"ø","th":"þ","DJ":"Đ","dj":"đ","i":"ı","IJ":"Ĳ","ij":"ĳ","L":"Ł","l":"ł","NG":"Ŋ","ng":"ŋ","OE":"Œ","oe":"œ","textflorin":"ƒ","j":"ȷ","textasciicaron":"ˇ","textasciibreve":"˘","textacutedbl":"˝","textgravedbl":"˵","texttildelow":"˷","textbaht":"฿","SS":"ẞ","textcompwordmark":"‌","textendash":"–","textemdash":"—","textbardbl":"‖","textquoteleft":"‘","textquoteright":"’","quotesinglbase":"‚","textquotedblleft":"“","textquotedblright":"”","quotedblbase":"„","textdagger":"†","textdaggerdbl":"‡","textbullet":"•","textellipsis":"…","textperthousand":"‰","textpertenthousand":"‱","guilsinglleft":"‹","guilsinglright":"›","textreferencemark":"※","textinterrobang":"‽","textfractionsolidus":"⁄","textlquill":"⁅","textrquill":"⁆","textdiscount":"⁒","textcolonmonetary":"₡","textlira":"₤","textnaira":"₦","textwon":"₩","textdong":"₫","texteuro":"€","textpeso":"₱","textcelsius":"℃","textnumero":"№","textcircledP":"℗","textrecipe":"℞","textservicemark":"℠","texttrademark":"™","textohm":"Ω","textmho":"℧","textestimated":"℮","textleftarrow":"←","textuparrow":"↑","textrightarrow":"→","textdownarrow":"↓","textminus":"−","Hwithstroke":"Ħ","hwithstroke":"ħ","textasteriskcentered":"∗","textsurd":"√","textlangle":"〈","textrangle":"〉","textblank":"␢","textvisiblespace":"␣","textopenbullet":"◦","textbigcircle":"◯","textmusicalnote":"♪","textmarried":"⚭","textdivorced":"⚮","textinterrobangdown":"⸘","textcommabelow":null,"copyright":"©"},"mathCommands":{"Gamma":"Γ","Delta":"Δ","Theta":"Θ","Lambda":"Λ","Xi":"Ξ","Pi":"Π","Sigma":"Σ","Phi":"Φ","Psi":"Ψ","Omega":"Ω","alpha":"α","beta":"β","gamma":"γ","delta":"δ","varepsilon":"ε","zeta":"ζ","eta":"η","theta":"θ","iota":"ι","kappa":"κ","lambda":"λ","mu":"μ","nu":"ν","xi":"ξ","pi":"π","rho":"ρ","varsigma":"ς","sigma":"σ","tau":"τ","upsilon":"υ","varphi":"φ","chi":"χ","psi":"ψ","omega":"ω","vartheta":"ϑ","Upsilon":"ϒ","phi":"ϕ","varpi":"ϖ","varrho":"ϱ","epsilon":"ϵ"}});}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib/input/constants.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sentenceCaseLanguages = exports.required = exports.mathScripts = exports.mathScriptFormatting = exports.mathCommands = exports.ligatures = exports.ligaturePattern = exports.formattingEnvs = exports.formattingCommands = exports.formatting = exports.fieldTypes = exports.diacritics = exports.defaultStrings = exports.commands = exports.argumentCommands = void 0;
var _required2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/input/required.json (json)"));
var _fieldTypes2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/input/fieldTypes.json (json)"));
var _unicode = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/input/unicode.json (json)"));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
const required = exports.required = _required2.default;
const fieldTypes = exports.fieldTypes = _fieldTypes2.default;
const diacritics = exports.diacritics = _unicode.default.diacritics;
const commands = exports.commands = _unicode.default.commands;
const mathCommands = exports.mathCommands = _unicode.default.mathCommands;
const defaultStrings = exports.defaultStrings = {
    jan: '01',
    feb: '02',
    mar: '03',
    apr: '04',
    may: '05',
    jun: '06',
    jul: '07',
    aug: '08',
    sep: '09',
    oct: '10',
    nov: '11',
    dec: '12',
    acmcs: 'ACM Computing Surveys',
    acta: 'Acta Informatica',
    cacm: 'Communications of the ACM',
    ibmjrd: 'IBM Journal of Research and Development',
    ibmsj: 'IBM Systems Journal',
    ieeese: 'IEEE Transactions on Software Engineering',
    ieeetc: 'IEEE Transactions on Computers',
    ieeetcad: 'IEEE Transactions on Computer-Aided Design of Integrated Circuits',
    ipl: 'Information Processing Letters',
    jacm: 'Journal of the ACM',
    jcss: 'Journal of Computer and System Sciences',
    scp: 'Science of Computer Programming',
    sicomp: 'SIAM Journal on Computing',
    tocs: 'ACM Transactions on Computer Systems',
    tods: 'ACM Transactions on Database Systems',
    tog: 'ACM Transactions on Graphics',
    toms: 'ACM Transactions on Mathematical Software',
    toois: 'ACM Transactions on Office Information Systems',
    toplas: 'ACM Transactions on Programming Languages and Systems',
    tcs: 'Theoretical Computer Science'
};
const formattingEnvs = exports.formattingEnvs = {
    it: 'italics',
    itshape: 'italics',
    sl: 'italics',
    slshape: 'italics',
    em: 'italics',
    bf: 'bold',
    bfseries: 'bold',
    sc: 'smallcaps',
    scshape: 'smallcaps',
    rm: undefined,
    sf: undefined,
    tt: undefined
};
const formattingCommands = exports.formattingCommands = {
    textit: 'italics',
    textsl: 'italics',
    emph: 'italics',
    mkbibitalic: 'italics',
    mkbibemph: 'italics',
    textbf: 'bold',
    strong: 'bold',
    mkbibbold: 'bold',
    textsc: 'smallcaps',
    textsuperscript: 'superscript',
    textsubscript: 'subscript',
    enquote: 'quotes',
    mkbibquote: 'quotes',
    textmd: undefined,
    textrm: undefined,
    textsf: undefined,
    texttt: undefined,
    textup: undefined
};
const formatting = exports.formatting = {
    italics: [
        '<i>',
        '</i>'
    ],
    bold: [
        '<b>',
        '</b>'
    ],
    superscript: [
        '<sup>',
        '</sup>'
    ],
    subscript: [
        '<sub>',
        '</sub>'
    ],
    smallcaps: [
        '<span style="font-variant:small-caps;">',
        '</span>'
    ],
    nocase: [
        '<span class="nocase">',
        '</span>'
    ],
    quotes: [
        '\u201C',
        '\u201D'
    ]
};
const argumentCommands = exports.argumentCommands = {
    ElsevierGlyph (glyph) {
        return String.fromCharCode(parseInt(glyph, 16));
    },
    href (url, text) {
        return url;
    },
    url (url) {
        return url;
    }
};
const ligaturePattern = exports.ligaturePattern = /---?|''|``|~/g;
const ligatures = exports.ligatures = {
    '--': '\u2013',
    '---': '\u2014',
    '``': '\u201C',
    "''": '\u201D',
    '~': '\u00A0'
};
const mathScriptFormatting = exports.mathScriptFormatting = {
    '^': 'superscript',
    sp: 'superscript',
    _: 'subscript',
    sb: 'subscript',
    mathrm: undefined
};
const mathScripts = exports.mathScripts = {
    '^': {
        '0': '\u2070',
        '1': '\u00B9',
        '2': '\u00B2',
        '3': '\u00B3',
        '4': '\u2074',
        '5': '\u2075',
        '6': '\u2076',
        '7': '\u2077',
        '8': '\u2078',
        '9': '\u2079',
        '+': '\u207A',
        '-': '\u207B',
        '=': '\u207C',
        '(': '\u207D',
        ')': '\u207E',
        'i': '\u2071',
        'n': '\u207F'
    },
    '_': {
        '0': '\u2080',
        '1': '\u2081',
        '2': '\u2082',
        '3': '\u2083',
        '4': '\u2084',
        '5': '\u2085',
        '6': '\u2086',
        '7': '\u2087',
        '8': '\u2088',
        '9': '\u2089',
        '+': '\u208A',
        '-': '\u208B',
        '=': '\u208C',
        '(': '\u208D',
        ')': '\u208E',
        'a': '\u2090',
        'e': '\u2091',
        'o': '\u2092',
        'x': '\u2093',
        '\u0259': '\u2094',
        'h': '\u2095',
        'k': '\u2096',
        'l': '\u2097',
        'm': '\u2098',
        'n': '\u2099',
        's': '\u209A',
        'p': '\u209B',
        't': '\u209C'
    }
};
const sentenceCaseLanguages = exports.sentenceCaseLanguages = [
    'american',
    'british',
    'canadian',
    'english',
    'australian',
    'newzealand',
    'usenglish',
    'ukenglish',
    'en',
    'eng',
    'en-au',
    'en-bz',
    'en-ca',
    'en-cb',
    'en-gb',
    'en-ie',
    'en-jm',
    'en-nz',
    'en-ph',
    'en-tt',
    'en-us',
    'en-za',
    'en-zw',
    'anglais'
];
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib/config.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _biblatexTypes = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/mapping/biblatexTypes.json (json)"));
var _bibtexTypes = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/mapping/bibtexTypes.json (json)"));
var constants = _interopRequireWildcard(__turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/input/constants.js [app-ssr] (ecmascript)"));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
var _default = exports.default = {
    constants,
    types: {
        biblatex: _biblatexTypes.default,
        bibtex: _bibtexTypes.default
    },
    parse: {
        biblatex: true,
        strict: false,
        sentenceCase: 'never'
    },
    format: {
        useIdAsLabel: false,
        checkLabel: true,
        asciiOnly: true
    },
    biber: {
        annotationMarker: '+an',
        namedAnnotationMarker: ':'
    }
};
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib/input/file.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bibtexGrammar = void 0;
exports.parse = parse;
var _core = __turbopack_context__.r("[project]/node_modules/@citation-js/core/lib-mjs/index.js [app-ssr] (ecmascript)");
var _moo = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/moo/moo.js [app-ssr] (ecmascript)"));
var _config = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/config.js [app-ssr] (ecmascript)"));
var _constants = __turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/input/constants.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
const identifier = /[a-zA-Z_][a-zA-Z0-9_:+-]*/;
const whitespace = {
    comment: /%.*/,
    whitespace: {
        match: /\s+/,
        lineBreaks: true
    }
};
const lexer = _moo.default.states({
    main: {
        junk: {
            match: /@[cC][oO][mM][mM][eE][nN][tT].+|[^@]+/,
            lineBreaks: true
        },
        at: {
            match: '@',
            push: 'entry'
        }
    },
    entry: _objectSpread(_objectSpread({}, whitespace), {}, {
        otherEntryType: {
            match: /[sS][tT][rR][iI][nN][gG]|[pP][rR][eE][aA][mM][bB][lL][eE]/,
            next: 'otherEntryContents'
        },
        dataEntryType: {
            match: identifier,
            next: 'dataEntryContents'
        }
    }),
    otherEntryContents: _objectSpread(_objectSpread({}, whitespace), {}, {
        lbrace: {
            match: /[{(]/,
            next: 'fields'
        }
    }),
    dataEntryContents: _objectSpread(_objectSpread({}, whitespace), {}, {
        lbrace: {
            match: /[{(]/,
            next: 'dataEntryContents'
        },
        label: /[^,\s]+/,
        comma: {
            match: ',',
            next: 'fields'
        }
    }),
    fields: _objectSpread(_objectSpread({}, whitespace), {}, {
        identifier,
        number: /-?\d+/,
        hash: '#',
        equals: '=',
        comma: ',',
        quote: {
            match: '"',
            push: 'quotedLiteral'
        },
        lbrace: {
            match: '{',
            push: 'bracedLiteral'
        },
        rbrace: {
            match: /[})]/,
            pop: true
        }
    }),
    quotedLiteral: {
        lbrace: {
            match: '{',
            push: 'bracedLiteral'
        },
        quote: {
            match: '"',
            pop: true
        },
        text: {
            match: /(?:\\[\\{]|[^{"])+/,
            lineBreaks: true
        }
    },
    bracedLiteral: {
        lbrace: {
            match: '{',
            push: 'bracedLiteral'
        },
        rbrace: {
            match: '}',
            pop: true
        },
        text: {
            match: /(?:\\[\\{}]|[^{}])+/,
            lineBreaks: true
        }
    }
});
const delimiters = {
    '(': ')',
    '{': '}'
};
const bibtexGrammar = exports.bibtexGrammar = new _core.util.Grammar({
    Main () {
        const entries = [];
        while(true){
            while(this.matchToken('junk')){
                this.consumeToken('junk');
            }
            if (this.matchEndOfFile()) {
                break;
            }
            entries.push(this.consumeRule('Entry'));
        }
        return entries.filter(Boolean);
    },
    _ () {
        let oldToken;
        while(oldToken !== this.token){
            oldToken = this.token;
            this.consumeToken('whitespace', true);
            this.consumeToken('comment', true);
        }
    },
    Entry () {
        this.consumeToken('at');
        this.consumeRule('_');
        const type = (this.matchToken('otherEntryType') ? this.consumeToken('otherEntryType') : this.consumeToken('dataEntryType')).value.toLowerCase();
        this.consumeRule('_');
        const openBrace = this.consumeToken('lbrace').value;
        this.consumeRule('_');
        let result;
        if (type === 'string') {
            const [key, value] = this.consumeRule('Field');
            this.state.strings[key] = value;
        } else if (type === 'preamble') {
            this.consumeRule('Expression');
        } else {
            const label = this.consumeToken('label').value;
            this.consumeRule('_');
            this.consumeToken('comma');
            this.consumeRule('_');
            const entryBody = this.consumeRule('EntryBody');
            result = _objectSpread({
                type,
                label
            }, entryBody);
        }
        this.consumeRule('_');
        const closeBrace = this.consumeToken('rbrace').value;
        if (closeBrace !== delimiters[openBrace]) {
            _core.logger.warn('[plugin-bibtex]', `entry started with "${openBrace}", but ends with "${closeBrace}"`);
        }
        return result;
    },
    EntryBody () {
        const output = {
            properties: {}
        };
        while(this.matchToken('identifier')){
            const [field, value] = this.consumeRule('Field');
            let annotationField;
            let annotationName = 'default';
            if (field.endsWith(_config.default.biber.annotationMarker)) {
                annotationField = field.slice(0, -_config.default.biber.annotationMarker.length);
            } else if (field.includes(_config.default.biber.annotationMarker + _config.default.biber.namedAnnotationMarker)) {
                [annotationField, annotationName] = field.split(_config.default.biber.annotationMarker + _config.default.biber.namedAnnotationMarker);
            }
            if (annotationField) {
                if (!output.annotations) {
                    output.annotations = {};
                }
                if (!output.annotations[annotationField]) {
                    output.annotations[annotationField] = {};
                }
                output.annotations[annotationField][annotationName] = value;
            } else {
                output.properties[field] = value;
            }
            this.consumeRule('_');
            if (this.consumeToken('comma', true)) {
                this.consumeRule('_');
            } else {
                break;
            }
        }
        return output;
    },
    Field () {
        const field = this.consumeToken('identifier').value.toLowerCase();
        this.consumeRule('_');
        this.consumeToken('equals');
        this.consumeRule('_');
        const value = this.consumeRule('Expression');
        return [
            field,
            value
        ];
    },
    Expression () {
        let output = this.consumeRule('ExpressionPart');
        this.consumeRule('_');
        while(this.matchToken('hash')){
            this.consumeToken('hash');
            this.consumeRule('_');
            output += this.consumeRule('ExpressionPart').toString();
            this.consumeRule('_');
        }
        return output;
    },
    ExpressionPart () {
        if (this.matchToken('identifier')) {
            return this.state.strings[this.consumeToken('identifier').value.toLowerCase()] || '';
        } else if (this.matchToken('number')) {
            return parseInt(this.consumeToken('number'));
        } else if (this.matchToken('quote')) {
            return this.consumeRule('QuoteString');
        } else {
            return this.consumeRule('BracketString');
        }
    },
    QuoteString () {
        let output = '';
        this.consumeToken('quote');
        while(!this.matchToken('quote')){
            output += this.consumeRule('Text');
        }
        this.consumeToken('quote');
        return output;
    },
    BracketString () {
        let output = '';
        this.consumeToken('lbrace');
        while(!this.matchToken('rbrace')){
            output += this.consumeRule('Text');
        }
        this.consumeToken('rbrace');
        return output;
    },
    Text () {
        if (this.matchToken('lbrace')) {
            return `{${this.consumeRule('BracketString')}}`;
        } else {
            return this.consumeToken('text').value;
        }
    }
}, {
    strings: _constants.defaultStrings
});
function parse(text) {
    return bibtexGrammar.parse(lexer.reset(text));
}
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib/input/bibtxt.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.textEntry = exports.text = exports.parse = void 0;
const bibTxtRegex = {
    splitEntries: /\n\s*(?=\[)/g,
    parseEntry: /^\[(.+?)\]\s*(?:\n([\s\S]+))?$/,
    splitPairs: /((?=.)\s)*\n\s*/g,
    splitPair: /:(.*)/
};
const parseBibTxtEntry = (entry)=>{
    const [, label, pairs] = entry.match(bibTxtRegex.parseEntry) || [];
    if (!label || !pairs) {
        return {};
    } else {
        const out = {
            type: 'book',
            label,
            properties: {}
        };
        pairs.trim().split(bibTxtRegex.splitPairs).filter((v)=>v).forEach((pair)=>{
            let [key, value] = pair.split(bibTxtRegex.splitPair);
            if (value) {
                key = key.trim();
                value = value.trim();
                if (key === 'type') {
                    out.type = value;
                } else {
                    out.properties[key] = value;
                }
            }
        });
        return out;
    }
};
exports.textEntry = parseBibTxtEntry;
const parseBibTxt = (src)=>src.trim().split(bibTxtRegex.splitEntries).map(parseBibTxtEntry);
exports.text = exports.parse = parseBibTxt;
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib/mapping/shared.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TYPE_KEYS = exports.TYPE = exports.STANDARD_NUMBERS_PATTERN = exports.MONTHS = exports.LABEL = exports.Converters = void 0;
exports.formatLabel = formatLabel;
exports.parseDate = parseDate;
exports.parseMonth = parseMonth;
var _core = __turbopack_context__.r("[project]/node_modules/@citation-js/core/lib-mjs/index.js [app-ssr] (ecmascript)");
var _config = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/config.js [app-ssr] (ecmascript)"));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
const stopWords = new Set([
    'the',
    'a',
    'an'
]);
const unsafeChars = /(?:<\/?.*?>|[\u0020-\u002F\u003A-\u0040\u005B-\u005E\u0060\u007B-\u007F])+/g;
const unicode = /[^\u0020-\u007F]+/g;
function isLabelSafe(text) {
    return !_config.default.format.checkLabel || !text.match(unsafeChars);
}
function formatLabelFromId(id) {
    if (id === null) {
        return 'null';
    } else if (id === undefined) {
        return 'undefined';
    } else if (_config.default.format.checkLabel) {
        return id.toString().replace(unsafeChars, '');
    } else {
        return id.toString();
    }
}
function firstWord(text) {
    if (!text) {
        return '';
    } else {
        return text.normalize('NFKD').replace(unicode, '').split(unsafeChars).find((word)=>word.length && !stopWords.has(word.toLowerCase()));
    }
}
const name = new _core.util.Translator([
    {
        source: 'given',
        target: 'given'
    },
    {
        source: 'family',
        target: 'family'
    },
    {
        source: 'suffix',
        target: 'suffix'
    },
    {
        source: 'prefix',
        target: 'non-dropping-particle'
    },
    {
        source: 'family',
        target: 'literal',
        when: {
            source: false,
            target: {
                family: false,
                given: false
            }
        }
    }
]);
const months = [
    'jan',
    'feb',
    'mar',
    'apr',
    'may',
    'jun',
    'jul',
    'aug',
    'sep',
    'oct',
    'nov',
    'dec'
];
const TYPE = exports.TYPE = 'BibTeX type';
const LABEL = exports.LABEL = 'BibTeX label';
const MONTHS = exports.MONTHS = {
    jan: 1,
    feb: 2,
    mar: 3,
    apr: 4,
    may: 5,
    jun: 6,
    jul: 7,
    aug: 8,
    sep: 9,
    oct: 10,
    nov: 11,
    dec: 12,
    january: 1,
    february: 2,
    march: 3,
    april: 4,
    may: 5,
    june: 6,
    july: 7,
    august: 8,
    september: 9,
    october: 10,
    november: 11,
    december: 12
};
const TYPE_KEYS = exports.TYPE_KEYS = {
    bathesis: 'Bachelor\'s thesis',
    mathesis: 'Master\'s thesis',
    phdthesis: 'PhD thesis',
    candthesis: 'Candidate thesis',
    techreport: 'technical report',
    resreport: 'research report',
    software: 'computer software',
    datacd: 'data cd',
    audiocd: 'audio cd',
    patent: 'patent',
    patentde: 'German patent',
    patenteu: 'European patent',
    patentfr: 'French patent',
    patentuk: 'British patent',
    patentus: 'U.S. patent',
    patreq: 'patent request',
    patreqde: 'German patent request',
    patreqeu: 'European patent request',
    patreqfr: 'French patent request',
    patrequk: 'British patent request',
    patrequs: 'U.S. patent request'
};
const STANDARD_NUMBERS_PATTERN = exports.STANDARD_NUMBERS_PATTERN = /(^(?:ISAN )?(?:[0-9a-f]{4}-){4}[0-9a-z](?:-(?:[0-9a-f]{4}-){2}[0-9a-z])?$)|(^(?:979-?0-?|M-?)(?:\d{9}|(?=[\d-]{11}$)\d+-\d+-\d)$)|(^ISRN .{1,36}$)|(^(?:ISWC )?T-?\d{9}-?\d$)/i;
function parseDate(date) {
    const parts = date.split('T')[0].replace(/[?~%]$/, '').split('-');
    const year = +parts[0].replace(/^Y(?=-?\d{4}\d+)/, '').replace(/X/g, '0');
    const month = +parts[1];
    const day = +parts[2];
    if (!month || month > 20) {
        return [
            year
        ];
    } else if (!day) {
        return [
            year,
            month
        ];
    } else {
        return [
            year,
            month,
            day
        ];
    }
}
function parseMonth(value) {
    if (value == null) {
        return [];
    }
    if (+value) {
        return [
            parseInt(value, 10)
        ];
    }
    value = value.trim().toLowerCase();
    if (value in MONTHS) {
        return [
            MONTHS[value]
        ];
    }
    const parts = value.split(/\s+/);
    let month;
    let day;
    if (parts[0] in MONTHS) {
        month = MONTHS[parts[0]];
        day = parseInt(parts[1]);
    } else if (parts[1] in MONTHS) {
        month = MONTHS[parts[1]];
        day = parseInt(parts[0]);
    }
    return day ? [
        month,
        day
    ] : month ? [
        month
    ] : [];
}
function formatLabel(author, issued, suffix, title) {
    let label = '';
    if (author && author[0]) {
        label += firstWord(author[0].family || author[0].literal);
    }
    if (issued && issued['date-parts'] && issued['date-parts'][0]) {
        label += issued['date-parts'][0][0];
    }
    if (suffix) {
        label += suffix;
    } else if (title) {
        label += firstWord(title);
    }
    return label;
}
const Converters = exports.Converters = {
    PICK: {
        toTarget (...args) {
            return args.find(Boolean);
        },
        toSource (value) {
            return [
                value
            ];
        }
    },
    DATE: {
        toTarget (date) {
            const parts = date.split('/').map((part)=>part && part !== '..' ? parseDate(part) : undefined);
            return isNaN(parts[0][0]) ? {
                literal: date
            } : {
                'date-parts': parts
            };
        },
        toSource (date) {
            if ('date-parts' in date) {
                return date['date-parts'].map((datePart)=>datePart.map((datePart)=>datePart.toString().padStart(2, '0')).join('-')).join('/');
            }
        }
    },
    YEAR_MONTH: {
        toTarget (year, month, day) {
            if (isNaN(+year)) {
                return {
                    literal: year
                };
            } else if (!isNaN(+day) && !isNaN(+month)) {
                return {
                    'date-parts': [
                        [
                            +year,
                            +month,
                            +day
                        ]
                    ]
                };
            } else {
                return {
                    'date-parts': [
                        [
                            +year,
                            ...parseMonth(month)
                        ]
                    ]
                };
            }
        },
        toSource (date) {
            if ('date-parts' in date) {
                const [year, month, day] = date['date-parts'][0];
                return [
                    year.toString(),
                    month ? day ? `${months[month - 1]} ${day}` : month : undefined
                ];
            } else {
                return [];
            }
        }
    },
    EPRINT: {
        toTarget (id, type) {
            if (type === 'pubmed') {
                return id;
            }
        },
        toSource (id) {
            return [
                id,
                'pubmed'
            ];
        }
    },
    EVENT_TITLE: {
        toTarget (title, addon) {
            if (addon) {
                title += ' (' + addon + ')';
            }
            return title;
        },
        toSource (title) {
            return title.match(/^(.+)(?: \((.+)\))?$/).slice(1, 3);
        }
    },
    HOW_PUBLISHED: {
        toTarget (howPublished) {
            if (howPublished.startsWith('http')) {
                return howPublished;
            }
        }
    },
    KEYWORDS: {
        toTarget (list) {
            return list.join(',');
        },
        toSource (list) {
            return list.split(',');
        }
    },
    LABEL: {
        toTarget (label) {
            return [
                label,
                label
            ];
        },
        toSource (id, label, author, issued, suffix, title) {
            if (label && isLabelSafe(label)) {
                return label;
            } else if (_config.default.format.useIdAsLabel) {
                return formatLabelFromId(id);
            } else {
                return formatLabel(author, issued, suffix, title) || formatLabelFromId(id);
            }
        }
    },
    NAMES: {
        toTarget (list) {
            return list.map(name.convertToTarget);
        },
        toSource (list) {
            return list.map(name.convertToSource);
        }
    },
    NAMES_ORCID: {
        toTarget (list, orcid) {
            return list.map((inputName, i)=>{
                var _orcid$item;
                const outputName = name.convertToTarget(inputName);
                if (typeof (orcid === null || orcid === void 0 || (_orcid$item = orcid.item) === null || _orcid$item === void 0 ? void 0 : _orcid$item[i]) === 'string') {
                    outputName._orcid = orcid.item[i];
                }
                return outputName;
            });
        },
        toSource (list) {
            const names = [];
            const orcid = [];
            for(let i = 0; i < list.length; i++){
                names.push(name.convertToSource(list[i]));
                if (list[i]._orcid) {
                    orcid[i] = list[i]._orcid;
                }
            }
            return [
                names,
                orcid.length ? {
                    item: orcid
                } : undefined
            ];
        }
    },
    PAGES: {
        toTarget (pages) {
            return pages.replace(/[–—]/, '-');
        },
        toSource (pages) {
            return pages.replace('-', '--');
        }
    },
    STANDARD_NUMBERS: {
        toTarget (...args) {
            return args.find(Boolean);
        },
        toSource (number) {
            const match = number.toString().match(STANDARD_NUMBERS_PATTERN);
            return match ? match.slice(1, 5) : [];
        }
    },
    STATUS: {
        toSource (state) {
            if (/^(inpreparation|submitted|forthcoming|inpress|prepublished)$/i.test(state)) {
                return state;
            }
        }
    },
    TITLE: {
        toTarget (title, subtitle, addon) {
            if (subtitle) {
                title += ': ' + subtitle;
            }
            return title;
        },
        toSource (title) {
            return [
                title
            ];
        }
    }
};
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib/mapping/biblatex.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _core = __turbopack_context__.r("[project]/node_modules/@citation-js/core/lib-mjs/index.js [app-ssr] (ecmascript)");
var _date = __turbopack_context__.r("[project]/node_modules/@citation-js/date/lib/index.js [app-ssr] (ecmascript)");
var _biblatexTypes = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/mapping/biblatexTypes.json (json)"));
var _shared = __turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/mapping/shared.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
const nonSpec = [
    {
        source: 'note',
        target: 'accessed',
        when: {
            source: false,
            target: {
                note: false,
                addendum: false
            }
        },
        convert: {
            toSource (accessed) {
                return `[Online; accessed ${(0, _date.format)(accessed)}]`;
            }
        }
    },
    {
        source: 'numpages',
        target: 'number-of-pages',
        when: {
            source: {
                pagetotal: false
            },
            target: false
        }
    },
    {
        source: 'pmid',
        target: 'PMID',
        when: {
            source: {
                eprinttype (type) {
                    return type !== 'pmid';
                },
                archiveprefix (type) {
                    return type !== 'pmid';
                }
            },
            target: false
        }
    },
    {
        source: 'pmcid',
        target: 'PMCID',
        when: {
            target: false
        }
    },
    {
        source: 's2id',
        target: 'custom',
        convert: {
            toTarget (S2ID) {
                return {
                    S2ID
                };
            },
            toSource ({ S2ID }) {
                return S2ID;
            }
        }
    }
];
const aliases = [
    {
        source: 'annote',
        target: 'annote',
        when: {
            source: {
                annotation: false
            },
            target: false
        }
    },
    {
        source: 'address',
        target: 'publisher-place',
        convert: _shared.Converters.PICK,
        when: {
            source: {
                location: false
            },
            target: false
        }
    },
    {
        source: [
            'eprint',
            'archiveprefix'
        ],
        target: 'PMID',
        convert: _shared.Converters.EPRINT,
        when: {
            source: {
                eprinttype: false
            },
            target: false
        }
    },
    {
        source: 'journal',
        target: 'container-title',
        when: {
            source: {
                maintitle: false,
                booktitle: false,
                journaltitle: false
            },
            target: false
        }
    },
    {
        source: 'school',
        target: 'publisher',
        convert: _shared.Converters.PICK,
        when: {
            source: {
                institution: false,
                organization: false,
                publisher: false
            },
            target: false
        }
    }
];
var _default = exports.default = new _core.util.Translator([
    ...aliases,
    ...nonSpec,
    {
        source: 'abstract',
        target: 'abstract'
    },
    {
        source: 'urldate',
        target: 'accessed',
        convert: _shared.Converters.DATE
    },
    {
        source: 'annotation',
        target: 'annote'
    },
    {
        source: [
            'author',
            'author+an:orcid'
        ],
        target: 'author',
        convert: _shared.Converters.NAMES_ORCID
    },
    {
        source: 'library',
        target: 'call-number'
    },
    {
        source: 'chapter',
        target: 'chapter-number'
    },
    {
        source: 'bookauthor',
        target: 'container-author',
        convert: _shared.Converters.NAMES
    },
    {
        source: [
            'maintitle',
            'mainsubtitle',
            'maintitleaddon'
        ],
        target: 'container-title',
        when: {
            source: true,
            target: {
                'number-of-volumes': true
            }
        },
        convert: _shared.Converters.TITLE
    },
    {
        source: [
            'booktitle',
            'booksubtitle',
            'booktitleaddon'
        ],
        target: 'container-title',
        when: {
            source: {
                maintitle: false
            },
            target: {
                'number-of-volumes': false,
                type (type) {
                    return !type || !type.startsWith('article');
                }
            }
        },
        convert: _shared.Converters.TITLE
    },
    {
        source: [
            'journaltitle',
            'journalsubtitle',
            'journaltitleaddon'
        ],
        target: 'container-title',
        when: {
            source: {
                [_shared.TYPE]: 'article'
            },
            target: {
                type: [
                    'article',
                    'article-newspaper',
                    'article-journal',
                    'article-magazine'
                ]
            }
        },
        convert: _shared.Converters.TITLE
    },
    {
        source: 'shortjournal',
        target: 'container-title-short',
        when: {
            source: {
                [_shared.TYPE]: 'article'
            },
            target: {
                type: [
                    'article',
                    'article-newspaper',
                    'article-journal',
                    'article-magazine'
                ]
            }
        }
    },
    {
        source: 'shortjournal',
        target: 'journalAbbreviation',
        when: {
            source: false,
            target: {
                'container-title-short': false
            }
        }
    },
    {
        source: 'number',
        target: 'collection-number',
        when: {
            source: {
                [_shared.TYPE]: [
                    'book',
                    'mvbook',
                    'inbook',
                    'bookinbook',
                    'suppbook',
                    'collection',
                    'mvcollection',
                    'incollection',
                    'suppcollection',
                    'manual',
                    'suppperiodical',
                    'proceedings',
                    'mvproceedings',
                    'refererence'
                ]
            },
            target: {
                type: [
                    'bill',
                    'book',
                    'broadcast',
                    'chapter',
                    'dataset',
                    'entry',
                    'entry-dictionary',
                    'entry-encyclopedia',
                    'figure',
                    'graphic',
                    'interview',
                    'legislation',
                    'legal_case',
                    'manuscript',
                    'map',
                    'motion_picture',
                    'musical_score',
                    'pamphlet',
                    'post',
                    'post-weblog',
                    'personal_communication',
                    'review',
                    'review-book',
                    'song',
                    'speech',
                    'thesis',
                    'treaty',
                    'webpage'
                ]
            }
        }
    },
    {
        source: 'series',
        target: 'collection-title'
    },
    {
        source: 'shortseries',
        target: 'collection-title-short'
    },
    {
        source: 'doi',
        target: 'DOI'
    },
    {
        source: 'edition',
        target: 'edition'
    },
    {
        source: 'editor',
        target: 'editor',
        convert: _shared.Converters.NAMES
    },
    {
        source: [
            _shared.TYPE,
            'entrysubtype',
            'type'
        ],
        target: [
            'type',
            'genre'
        ],
        convert: {
            toTarget (type, subtype, typeKey) {
                if (!typeKey) {
                    if (type === 'mastersthesis') {
                        typeKey = 'mathesis';
                    }
                    if (type === 'phdthesis') {
                        typeKey = 'phdthesis';
                    }
                    if (type === 'techreport') {
                        typeKey = 'techreport';
                    }
                }
                return [
                    _biblatexTypes.default.source[type] || 'document',
                    typeKey || subtype
                ];
            },
            toSource (type, genre) {
                const sourceType = _biblatexTypes.default.target[type] || 'misc';
                return genre in _shared.TYPE_KEYS ? [
                    sourceType,
                    undefined,
                    genre
                ] : [
                    sourceType,
                    genre
                ];
            }
        }
    },
    {
        source: _shared.TYPE,
        when: {
            target: {
                type: false
            }
        },
        convert: {
            toSource () {
                return 'misc';
            }
        }
    },
    {
        source: 'eventdate',
        target: 'event-date',
        convert: _shared.Converters.DATE
    },
    {
        source: 'venue',
        target: 'event-place'
    },
    {
        source: [
            'eventtitle',
            'eventtitleaddon'
        ],
        target: 'event-title',
        convert: _shared.Converters.EVENT_TITLE
    },
    {
        source: [
            'eventtitle',
            'eventtitleaddon'
        ],
        target: 'event',
        convert: _shared.Converters.EVENT_TITLE,
        when: {
            source: false,
            target: {
                'event-title': false
            }
        }
    },
    {
        source: _shared.LABEL,
        target: [
            'id',
            'citation-key',
            'author',
            'issued',
            'year-suffix',
            'title'
        ],
        convert: _shared.Converters.LABEL
    },
    {
        source: 'isbn',
        target: 'ISBN'
    },
    {
        source: 'issn',
        target: 'ISSN'
    },
    {
        source: 'issue',
        target: 'issue',
        when: {
            source: {
                number: false,
                [_shared.TYPE]: [
                    'article',
                    'periodical'
                ]
            },
            target: {
                issue (issue) {
                    return typeof issue === 'string' && !issue.match(/\d+/);
                },
                type: [
                    'article',
                    'article-journal',
                    'article-newspaper',
                    'article-magazine',
                    'periodical'
                ]
            }
        }
    },
    {
        source: 'number',
        target: 'issue',
        when: {
            source: {
                [_shared.TYPE]: [
                    'article',
                    'periodical',
                    'inproceedings'
                ]
            },
            target: {
                issue (issue) {
                    return issue && (typeof issue === 'number' || issue.match(/\d+/));
                },
                type: [
                    'article',
                    'article-journal',
                    'article-newspaper',
                    'article-magazine',
                    'paper-conference',
                    'periodical'
                ]
            }
        }
    },
    {
        source: 'date',
        target: 'issued',
        convert: _shared.Converters.DATE
    },
    {
        source: [
            'year',
            'month',
            'day'
        ],
        target: 'issued',
        convert: _shared.Converters.YEAR_MONTH,
        when: {
            source: {
                date: false
            },
            target: false
        }
    },
    {
        source: 'location',
        target: 'jurisdiction',
        when: {
            source: {
                type: 'patent'
            },
            target: {
                type: 'patent'
            }
        }
    },
    {
        source: 'keywords',
        target: 'keyword',
        convert: _shared.Converters.KEYWORDS
    },
    {
        source: 'language',
        target: 'language',
        convert: _shared.Converters.PICK
    },
    {
        source: 'langid',
        target: 'language',
        when: {
            source: {
                language: false
            },
            target: false
        }
    },
    {
        source: 'note',
        target: 'note'
    },
    {
        source: 'addendum',
        target: 'note',
        when: {
            source: {
                note: false
            },
            target: false
        }
    },
    {
        source: 'eid',
        target: 'number',
        when: {
            target: {
                type: [
                    'article-journal'
                ]
            }
        }
    },
    {
        source: [
            'isan',
            'ismn',
            'isrn',
            'iswc'
        ],
        target: 'number',
        convert: _shared.Converters.STANDARD_NUMBERS,
        when: {
            source: {
                [_shared.TYPE] (type) {
                    return type !== 'patent';
                }
            },
            target: {
                type (type) {
                    return type !== 'patent';
                }
            }
        }
    },
    {
        source: 'number',
        target: 'number',
        when: {
            source: {
                [_shared.TYPE]: [
                    'patent',
                    'report',
                    'techreport',
                    'legislation'
                ]
            },
            target: {
                type: [
                    'patent',
                    'report',
                    'legislation'
                ]
            }
        }
    },
    {
        source: 'origdate',
        target: 'original-date',
        convert: _shared.Converters.DATE
    },
    {
        source: 'origlocation',
        target: 'original-publisher-place',
        convert: _shared.Converters.PICK
    },
    {
        source: 'origpublisher',
        target: 'original-publisher',
        convert: _shared.Converters.PICK
    },
    {
        source: 'origtitle',
        target: 'original-title'
    },
    {
        source: 'pages',
        target: 'page',
        when: {
            source: {
                bookpagination: [
                    undefined,
                    'page'
                ]
            }
        },
        convert: _shared.Converters.PAGES
    },
    {
        source: 'pagetotal',
        target: 'number-of-pages'
    },
    {
        source: 'part',
        target: 'part-number'
    },
    {
        source: [
            'eprint',
            'eprinttype'
        ],
        target: 'PMID',
        convert: _shared.Converters.EPRINT
    },
    {
        source: 'location',
        target: 'publisher-place',
        convert: _shared.Converters.PICK
    },
    {
        source: 'publisher',
        target: 'publisher',
        convert: _shared.Converters.PICK,
        when: {
            source: true,
            target: {
                type: [
                    'article',
                    'article-journal',
                    'article-magazine',
                    'article-newspaper',
                    'bill',
                    'book',
                    'broadcast',
                    'chapter',
                    'classic',
                    'collection',
                    'dataset',
                    'document',
                    'entry',
                    'entry-dictionary',
                    'entry-encyclopedia',
                    'event',
                    'figure',
                    'graphic',
                    'hearing',
                    'interview',
                    'legal_case',
                    'legislation',
                    'manuscript',
                    'map',
                    'motion_picture',
                    'musical_score',
                    'pamphlet',
                    'patent',
                    'performance',
                    'periodical',
                    'personal_communication',
                    'post',
                    'post-weblog',
                    'regulation',
                    'review',
                    'review-book',
                    'software',
                    'song',
                    'speech',
                    'standard',
                    'treaty'
                ]
            }
        }
    },
    {
        source: 'organization',
        target: 'publisher',
        convert: _shared.Converters.PICK,
        when: {
            source: {
                publisher: false
            },
            target: {
                type: [
                    'paper-conference',
                    'webpage'
                ]
            }
        }
    },
    {
        source: 'institution',
        target: 'publisher',
        convert: _shared.Converters.PICK,
        when: {
            source: {
                publisher: false,
                organization: false
            },
            target: {
                type: [
                    'report',
                    'thesis'
                ]
            }
        }
    },
    {
        source: 'howpublished',
        target: 'publisher',
        convert: _shared.Converters.PICK,
        when: {
            source: {
                howpublished (howPublished) {
                    return howPublished && !howPublished.startsWith('http');
                },
                publisher: false,
                organization: false,
                institution: false
            },
            target: {
                type: 'manuscript'
            }
        }
    },
    {
        source: [
            'pages',
            'bookpagination'
        ],
        target: 'section',
        when: {
            source: {
                bookpagination: 'section'
            },
            target: {
                page: false
            }
        },
        convert: {
            toTarget (section) {
                return section;
            },
            toSource (section) {
                return [
                    section,
                    'section'
                ];
            }
        }
    },
    {
        source: 'pubstate',
        target: 'status',
        convert: _shared.Converters.STATUS
    },
    {
        source: 'shorttitle',
        target: 'title-short'
    },
    {
        source: 'shorttitle',
        target: 'shortTitle',
        when: {
            source: false,
            target: {
                'title-short': false
            }
        }
    },
    {
        source: [
            'title',
            'subtitle',
            'titleaddon'
        ],
        target: 'title',
        convert: _shared.Converters.TITLE
    },
    {
        source: 'translator',
        target: 'translator',
        convert: _shared.Converters.NAMES
    },
    {
        source: 'url',
        target: 'URL'
    },
    {
        source: 'howpublished',
        target: 'URL',
        convert: _shared.Converters.HOW_PUBLISHED,
        when: {
            source: {
                url: false
            },
            target: false
        }
    },
    {
        source: 'version',
        target: 'version'
    },
    {
        source: 'volume',
        target: 'volume'
    },
    {
        source: 'volumes',
        target: 'number-of-volumes'
    },
    {
        source: [
            'issuetitle',
            'issuesubtitle',
            'issuetitleaddon'
        ],
        target: 'volume-title',
        convert: _shared.Converters.TITLE
    }
]);
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib/mapping/bibtex.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _core = __turbopack_context__.r("[project]/node_modules/@citation-js/core/lib-mjs/index.js [app-ssr] (ecmascript)");
var _date = __turbopack_context__.r("[project]/node_modules/@citation-js/date/lib/index.js [app-ssr] (ecmascript)");
var _bibtexTypes = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/mapping/bibtexTypes.json (json)"));
var _shared = __turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/mapping/shared.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
var _default = exports.default = new _core.util.Translator([
    {
        source: 'note',
        target: 'accessed',
        when: {
            source: false,
            target: {
                note: false
            }
        },
        convert: {
            toSource (accessed) {
                return `[Online; accessed ${(0, _date.format)(accessed)}]`;
            }
        }
    },
    {
        source: 'annote',
        target: 'annote'
    },
    {
        source: 'address',
        target: 'publisher-place',
        convert: _shared.Converters.PICK
    },
    {
        source: 'author',
        target: 'author',
        convert: _shared.Converters.NAMES
    },
    {
        source: 'chapter',
        target: 'chapter-number'
    },
    {
        source: 'number',
        target: 'collection-number',
        when: {
            source: {
                [_shared.TYPE]: [
                    'book',
                    'mvbook',
                    'inbook',
                    'collection',
                    'mvcollection',
                    'incollection',
                    'suppcollection',
                    'manual',
                    'suppperiodical',
                    'proceedings',
                    'mvproceedings',
                    'refererence'
                ]
            },
            target: {
                type: [
                    'bill',
                    'book',
                    'broadcast',
                    'chapter',
                    'dataset',
                    'entry',
                    'entry-dictionary',
                    'entry-encyclopedia',
                    'figure',
                    'graphic',
                    'interview',
                    'legislation',
                    'legal_case',
                    'manuscript',
                    'map',
                    'motion_picture',
                    'musical_score',
                    'pamphlet',
                    'post',
                    'post-weblog',
                    'personal_communication',
                    'review',
                    'review-book',
                    'song',
                    'speech',
                    'thesis',
                    'treaty',
                    'webpage'
                ]
            }
        }
    },
    {
        source: 'series',
        target: 'collection-title'
    },
    {
        source: 'booktitle',
        target: 'container-title',
        when: {
            target: {
                type: [
                    'chapter',
                    'paper-conference'
                ]
            }
        }
    },
    {
        source: 'journal',
        target: 'container-title',
        when: {
            source: {
                [_shared.TYPE]: 'article'
            },
            target: {
                type: [
                    'article',
                    'article-newspaper',
                    'article-journal',
                    'article-magazine'
                ]
            }
        }
    },
    {
        source: 'doi',
        target: 'DOI'
    },
    {
        source: 'edition',
        target: 'edition'
    },
    {
        source: 'editor',
        target: 'editor',
        convert: _shared.Converters.NAMES
    },
    {
        source: _shared.LABEL,
        target: [
            'id',
            'citation-key',
            'author',
            'issued',
            'year-suffix',
            'title'
        ],
        convert: _shared.Converters.LABEL
    },
    {
        source: 'isbn',
        target: 'ISBN'
    },
    {
        source: 'issn',
        target: 'ISSN'
    },
    {
        source: 'number',
        target: 'issue',
        when: {
            source: {
                [_shared.TYPE]: [
                    'article',
                    'periodical',
                    'inproceedings'
                ]
            },
            target: {
                issue (issue) {
                    return typeof issue === 'number' || typeof issue === 'string' && issue.match(/\d+/);
                },
                type: [
                    'article',
                    'article-journal',
                    'article-newspaper',
                    'article-magazine',
                    'paper-conference',
                    'periodical'
                ]
            }
        }
    },
    {
        source: [
            'year',
            'month',
            'day'
        ],
        target: 'issued',
        convert: _shared.Converters.YEAR_MONTH
    },
    {
        source: 'note',
        target: 'note'
    },
    {
        source: 'number',
        target: 'number',
        when: {
            source: {
                [_shared.TYPE]: [
                    'patent',
                    'report',
                    'techreport'
                ]
            },
            target: {
                type: [
                    'patent',
                    'report'
                ]
            }
        }
    },
    {
        source: 'eid',
        target: 'number',
        when: {
            source: {
                number: false
            },
            target: {
                type: [
                    'article-journal'
                ]
            }
        }
    },
    {
        source: 'pages',
        target: 'page',
        convert: _shared.Converters.PAGES
    },
    {
        source: 'publisher',
        target: 'publisher',
        convert: _shared.Converters.PICK,
        when: {
            target: {
                type: [
                    'article',
                    'article-journal',
                    'article-magazine',
                    'article-newspaper',
                    'bill',
                    'book',
                    'broadcast',
                    'chapter',
                    'classic',
                    'collection',
                    'dataset',
                    'document',
                    'entry',
                    'entry-dictionary',
                    'entry-encyclopedia',
                    'event',
                    'figure',
                    'graphic',
                    'hearing',
                    'interview',
                    'legal_case',
                    'legislation',
                    'map',
                    'motion_picture',
                    'musical_score',
                    'pamphlet',
                    'patent',
                    'performance',
                    'periodical',
                    'personal_communication',
                    'post',
                    'post-weblog',
                    'regulation',
                    'review',
                    'review-book',
                    'software',
                    'song',
                    'speech',
                    'standard',
                    'treaty',
                    'webpage'
                ]
            }
        }
    },
    {
        source: 'organization',
        target: 'publisher',
        convert: _shared.Converters.PICK,
        when: {
            source: {
                publisher: false
            },
            target: {
                type: 'paper-conference'
            }
        }
    },
    {
        source: 'institution',
        target: 'publisher',
        convert: _shared.Converters.PICK,
        when: {
            source: {
                publisher: false,
                organization: false
            },
            target: {
                type: 'report'
            }
        }
    },
    {
        source: 'school',
        target: 'publisher',
        convert: _shared.Converters.PICK,
        when: {
            source: {
                institution: false,
                organization: false,
                publisher: false
            },
            target: {
                type: 'thesis'
            }
        }
    },
    {
        source: 'howpublished',
        target: 'publisher',
        convert: _shared.Converters.PICK,
        when: {
            source: {
                howpublished (howPublished) {
                    return howPublished && !howPublished.startsWith('http');
                },
                publisher: false,
                organization: false,
                institution: false,
                school: false
            },
            target: {
                type: 'manuscript'
            }
        }
    },
    {
        source: 'title',
        target: 'title'
    },
    {
        source: [
            _shared.TYPE,
            'type'
        ],
        target: [
            'type',
            'genre'
        ],
        convert: {
            toTarget (sourceType, subType) {
                const type = _bibtexTypes.default.source[sourceType] || 'document';
                if (subType) {
                    return [
                        type,
                        subType
                    ];
                } else if (sourceType === 'mastersthesis') {
                    return [
                        type,
                        'Master\'s thesis'
                    ];
                } else if (sourceType === 'phdthesis') {
                    return [
                        type,
                        'PhD thesis'
                    ];
                } else {
                    return [
                        type
                    ];
                }
            },
            toSource (targetType, genre) {
                const type = _bibtexTypes.default.target[targetType] || 'misc';
                if (/^(master'?s|diploma) thesis$/i.test(genre)) {
                    return [
                        'mastersthesis'
                    ];
                } else if (/^(phd|doctoral) thesis$/i.test(genre)) {
                    return [
                        'phdthesis'
                    ];
                } else {
                    return [
                        type,
                        genre
                    ];
                }
            }
        }
    },
    {
        source: _shared.TYPE,
        when: {
            target: {
                type: false
            }
        },
        convert: {
            toSource () {
                return 'misc';
            }
        }
    },
    {
        source: 'url',
        target: 'URL'
    },
    {
        source: 'howpublished',
        target: 'URL',
        convert: _shared.Converters.HOW_PUBLISHED,
        when: {
            target: {
                publisher: false
            }
        }
    },
    {
        source: 'volume',
        target: 'volume'
    }
]);
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib/mapping/crossref.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.crossref = crossref;
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
const BOOK = new Set([
    'book',
    'inbook',
    'bookinbook',
    'suppbook'
]);
const BOOK_PART = new Set([
    'inbook',
    'bookinbook',
    'suppbook'
]);
const COLLECTION = new Set([
    'collection',
    'reference',
    'incollection',
    'inreference',
    'suppcollection'
]);
const COLLECTION_PART = new Set([
    'incollection',
    'inreference',
    'suppcollection'
]);
const PROCEEDINGS = new Set([
    'proceedings',
    'inproceedings'
]);
const PROCEEDINGS_PART = new Set([
    'inproceedings'
]);
const PERIODICAL_PART = new Set([
    'article',
    'suppperiodical'
]);
const TITLE_MAP = {
    mvbook: [
        'main',
        BOOK
    ],
    mvcollection: [
        'main',
        COLLECTION
    ],
    mvreference: [
        'main',
        COLLECTION
    ],
    mvproceedings: [
        'main',
        PROCEEDINGS
    ],
    book: [
        'book',
        BOOK_PART
    ],
    collection: [
        'book',
        COLLECTION_PART
    ],
    reference: [
        'book',
        COLLECTION_PART
    ],
    proceedings: [
        'book',
        PROCEEDINGS_PART
    ],
    periodical: [
        'journal',
        PERIODICAL_PART
    ]
};
function crossref(target, entry, registry) {
    if (entry.crossref in registry) {
        const parent = registry[entry.crossref];
        if (parent.properties === entry) {
            return entry;
        }
        const data = _objectSpread({}, crossref(parent.type, parent.properties, registry));
        delete data.ids;
        delete data.crossref;
        delete data.xref;
        delete data.entryset;
        delete data.entrysubtype;
        delete data.execute;
        delete data.label;
        delete data.options;
        delete data.presort;
        delete data.related;
        delete data.relatedoptions;
        delete data.relatedstring;
        delete data.relatedtype;
        delete data.shortand;
        delete data.shortandintro;
        delete data.sortkey;
        if ((parent.type === 'mvbook' || parent.type === 'book') && BOOK_PART.has(target)) {
            data.bookauthor = data.author;
        }
        if (parent.type in TITLE_MAP) {
            const [prefix, targets] = TITLE_MAP[parent.type];
            if (targets.has(target)) {
                data[prefix + 'title'] = data.title;
                data[prefix + 'subtitle'] = data.subtitle;
                if (prefix !== 'journal') {
                    data[prefix + 'titleaddon'] = data.titleaddon;
                }
                delete data.title;
                delete data.subtitle;
                delete data.titleaddon;
                delete data.shorttitle;
                delete data.sorttitle;
                delete data.indextitle;
                delete data.indexsorttitle;
            }
        }
        return Object.assign(data, entry);
    }
    return entry;
}
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib/mapping/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.format = format;
exports.formatBibtex = formatBibtex;
exports.parse = parse;
exports.parseBibtex = parseBibtex;
var _shared = __turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/mapping/shared.js [app-ssr] (ecmascript)");
var _biblatex = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/mapping/biblatex.js [app-ssr] (ecmascript)"));
var _bibtex = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/mapping/bibtex.js [app-ssr] (ecmascript)"));
var _crossref = __turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/mapping/crossref.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
function _objectWithoutProperties(e, t) {
    if (null == e) return {};
    var o, r, i = _objectWithoutPropertiesLoose(e, t);
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(e);
        for(r = 0; r < s.length; r++)o = s[r], t.includes(o) || ({}).propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
}
function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for(var n in r)if (({}).hasOwnProperty.call(r, n)) {
        if (e.includes(n)) continue;
        t[n] = r[n];
    }
    return t;
}
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function _parse(input, spec) {
    const registry = {};
    for (const entry of input){
        registry[entry.label] = entry;
    }
    return input.map(({ type, label, properties })=>spec.convertToTarget(_objectSpread({
            [_shared.TYPE]: type,
            [_shared.LABEL]: label
        }, (0, _crossref.crossref)(type, properties, registry))));
}
function _format(input, spec) {
    return input.map((entry)=>{
        const _spec$convertToSource = spec.convertToSource(entry), { [_shared.TYPE]: type, [_shared.LABEL]: label } = _spec$convertToSource, properties = _objectWithoutProperties(_spec$convertToSource, [
            _shared.TYPE,
            _shared.LABEL
        ].map(_toPropertyKey));
        return {
            type,
            label,
            properties
        };
    });
}
function parseBibtex(input) {
    return _parse(input, _bibtex.default);
}
function formatBibtex(input) {
    return _format(input, _bibtex.default);
}
function parse(input) {
    return _parse(input, _biblatex.default);
}
function format(input) {
    return _format(input, _biblatex.default);
}
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib/input/name.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.formatNameParts = formatNameParts;
exports.getStringCase = getStringCase;
exports.orderNameParts = orderNameParts;
exports.orderNamePieces = orderNamePieces;
function getStringCase(string) {
    const a = string.toUpperCase();
    const b = string.toLowerCase();
    for(let i = 0; i < string.length; i++){
        if (a[i] !== b[i]) {
            return a[i] === string[i];
        }
    }
    return null;
}
function formatNameParts(parts) {
    if (parts.length === 0) {
        return undefined;
    }
    let piece = '';
    while(parts.length > 1){
        const { value, hyphenated } = parts.shift();
        piece += value + (hyphenated ? '-' : ' ');
    }
    const output = piece + parts[0].value;
    return output[0] && output;
}
function orderNameParts(parts, orderGiven = true) {
    const given = [];
    const undecided = [];
    if (orderGiven) {
        while(parts.length > 1 && parts[0].upperCase !== false){
            given.push(...undecided);
            undecided.length = 0;
            while(parts.length > 1 && parts[0].upperCase !== false && !parts[0].hyphenated){
                given.push(parts.shift());
            }
            while(parts.length > 0 && parts[0].upperCase !== false && parts[0].hyphenated){
                undecided.push(parts.shift());
            }
        }
    }
    const prefix = [];
    const family = [];
    while(parts.length > 1){
        prefix.push(...family);
        family.length = 0;
        while(parts.length > 1 && parts[0].upperCase === false){
            prefix.push(parts.shift());
        }
        while(parts.length > 0 && parts[0].upperCase !== false){
            family.push(parts.shift());
        }
    }
    if (undecided.length) {
        family.unshift(...undecided);
    }
    if (parts.length) {
        family.push(parts[0]);
    }
    return [
        formatNameParts(given),
        formatNameParts(prefix),
        formatNameParts(family)
    ];
}
function orderNamePieces(pieces) {
    if (pieces[0][0].label) {
        const name = {};
        for (const [{ value, label }] of pieces){
            name[label] = value;
        }
        return name;
    }
    const name = {};
    const [given, prefix, family] = orderNameParts(pieces[0], pieces.length === 1);
    if (family) {
        name.family = family;
    }
    if (prefix) {
        name.prefix = prefix;
    }
    if (pieces.length === 3) {
        name.given = formatNameParts(pieces[2]);
        name.suffix = formatNameParts(pieces[1]);
    } else if (pieces.length === 2) {
        name.given = formatNameParts(pieces[1]);
    } else if (given) {
        name.given = given;
    }
    return name;
}
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib/input/value.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parse = parse;
exports.parseAnnotation = parseAnnotation;
exports.valueGrammar = void 0;
var _core = __turbopack_context__.r("[project]/node_modules/@citation-js/core/lib-mjs/index.js [app-ssr] (ecmascript)");
var _moo = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/moo/moo.js [app-ssr] (ecmascript)"));
var _config = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/config.js [app-ssr] (ecmascript)"));
var constants = _interopRequireWildcard(__turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/input/constants.js [app-ssr] (ecmascript)"));
var _name = __turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/input/name.js [app-ssr] (ecmascript)");
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
const text = {
    commandBegin: {
        match: '\\begin',
        push: 'environment'
    },
    command: {
        match: /\\(?:[a-zA-Z]+|.) */,
        value: (s)=>s.slice(1).trim()
    },
    lbrace: {
        match: '{',
        push: 'bracedLiteral'
    },
    mathShift: {
        match: '$',
        push: 'mathLiteral'
    },
    whitespace: {
        match: /[\s]+|~/,
        lineBreaks: true,
        value (token) {
            return token === '~' ? '\xa0' : ' ';
        }
    }
};
const lexer = _moo.default.states({
    stringLiteral: _objectSpread(_objectSpread({}, text), {}, {
        text: /[^{$}\s~\\]+/
    }),
    namesLiteral: _objectSpread(_objectSpread({
        and: /\s+[aA][nN][dD]\s+/,
        comma: ',',
        hyphen: '-',
        equals: '='
    }, text), {}, {
        text: /[^{$}\s~\\,=-]+/
    }),
    listLiteral: _objectSpread(_objectSpread({
        and: /\s+and\s+/
    }, text), {}, {
        text: /[^{$}\s~\\]+/
    }),
    separatedLiteral: _objectSpread(_objectSpread({
        comma: ','
    }, text), {}, {
        text: /[^{$}\s~\\,]+/
    }),
    annotation: _objectSpread(_objectSpread({}, text), {}, {
        colon: ':',
        equals: '=',
        comma: ',',
        semicolon: ';',
        quote: '"',
        itemCount: /\d+/,
        text: /[^{$}\s~\\":;,=]+/
    }),
    bracedLiteral: _objectSpread(_objectSpread({}, text), {}, {
        rbrace: {
            match: '}',
            pop: true
        },
        text: /[^{$}\s~\\]+/
    }),
    mathLiteral: _objectSpread(_objectSpread({}, text), {}, {
        mathShift: {
            match: '$',
            pop: true
        },
        script: /[\^_]/,
        text: /[^{$}\s~\\^_]+/
    }),
    environment: _objectSpread(_objectSpread({
        commandEnd: {
            match: '\\end',
            pop: true
        }
    }, text), {}, {
        text: /[^{$}\s~\\]+/
    })
});
function flattenConsString(string) {
    string[0];
    return string;
}
function applyFormatting(text, format) {
    if (format in constants.formatting) {
        return text && constants.formatting[format].join(text);
    } else {
        return text;
    }
}
const valueGrammar = exports.valueGrammar = new _core.util.Grammar({
    String () {
        let output = '';
        while(!this.matchEndOfFile()){
            output += this.consumeRule('Text');
        }
        return flattenConsString(output);
    },
    StringNames () {
        const list = [];
        while(true){
            this.consumeToken('whitespace', true);
            list.push(this.consumeRule('Name'));
            this.consumeToken('whitespace', true);
            if (this.matchEndOfFile()) {
                return list;
            } else {
                this.consumeToken('and');
            }
        }
    },
    Name () {
        const pieces = [];
        while(true){
            pieces.push(this.consumeRule('NamePiece'));
            if (this.matchEndOfFile() || this.matchToken('and')) {
                return (0, _name.orderNamePieces)(pieces);
            } else {
                this.consumeToken('comma');
                this.consumeToken('whitespace', true);
            }
        }
    },
    NamePiece () {
        const parts = [];
        while(true){
            const part = this.consumeRule('NameToken');
            if (part.label) {
                part.label = (0, _name.formatNameParts)([
                    ...parts,
                    {
                        value: part.label
                    }
                ]);
                return [
                    part
                ];
            }
            parts.push(part);
            if (this.matchEndOfFile() || this.matchToken('and') || this.matchToken('comma')) {
                return parts;
            } else {
                while(this.matchToken('hyphen') || this.matchToken('whitespace')){
                    this.consumeToken();
                }
            }
        }
    },
    NameToken () {
        let upperCase = null;
        let value = '';
        while(true){
            if (upperCase === null && this.matchToken('text')) {
                const text = this.consumeToken().value;
                value += text;
                upperCase = (0, _name.getStringCase)(text);
            } else if (this.matchEndOfFile() || this.matchToken('and') || this.matchToken('comma') || this.matchToken('whitespace')) {
                return {
                    value,
                    upperCase
                };
            } else if (this.matchToken('hyphen')) {
                return {
                    value,
                    upperCase,
                    hyphenated: true
                };
            } else if (this.matchToken('equals')) {
                this.consumeToken('equals');
                const text = this.consumeRule('NamePiece');
                if (text[0].label) {
                    value += '=' + text[0].label;
                }
                return {
                    value: (0, _name.formatNameParts)(text),
                    label: value
                };
            } else {
                value += this.consumeRule('Text');
            }
        }
    },
    StringList () {
        const list = [];
        while(!this.matchEndOfFile()){
            let output = '';
            while(!this.matchEndOfFile() && !this.matchToken('and')){
                output += this.consumeRule('Text');
            }
            list.push(flattenConsString(output));
            this.consumeToken('and', true);
        }
        return list.length === 1 ? list[0] : list;
    },
    StringSeparated () {
        const list = [];
        while(!this.matchEndOfFile()){
            let output = '';
            while(!this.matchEndOfFile() && !this.matchToken('comma')){
                output += this.consumeRule('Text');
            }
            list.push(output.trim());
            this.consumeToken('comma', true);
            this.consumeToken('whitespace', true);
        }
        return list;
    },
    StringVerbatim () {
        let output = '';
        while(!this.matchEndOfFile()){
            output += this.consumeToken().text;
        }
        return flattenConsString(output);
    },
    StringUri () {
        const uri = this.consumeRule('StringVerbatim');
        try {
            if (decodeURI(uri) === uri) {
                return encodeURI(uri);
            } else {
                return uri;
            }
        } catch (e) {
            return encodeURI(uri);
        }
    },
    StringTitleCase () {
        this.state.sentenceCase = true;
        let output = '';
        while(!this.matchEndOfFile()){
            output += this.consumeRule('Text');
        }
        return flattenConsString(output);
    },
    Annotations () {
        const annotations = {};
        while(true){
            const { scope, item, part, value } = this.consumeRule('Annotation');
            if (scope === 'part') {
                if (!annotations.part) {
                    annotations.part = [];
                }
                if (!annotations.part[item]) {
                    annotations.part[item] = {};
                }
                annotations.part[item][part] = value;
            } else if (scope === 'item') {
                if (!annotations.item) {
                    annotations.item = [];
                }
                annotations.item[item] = value;
            } else {
                annotations.field = value;
            }
            if (this.matchEndOfFile()) {
                break;
            } else {
                this.consumeToken('semicolon');
                this.consumeRule('_');
            }
        }
        return annotations;
    },
    Annotation () {
        const annotation = {};
        if (this.matchToken('itemCount')) {
            annotation.item = parseInt(this.consumeToken('itemCount')) - 1;
            if (this.matchToken('colon')) {
                this.consumeToken('colon');
                annotation.part = this.consumeToken('text');
                annotation.scope = 'part';
            } else {
                annotation.scope = 'item';
            }
        } else {
            annotation.scope = 'field';
        }
        this.consumeToken('equals');
        this.consumeRule('_');
        if (this.matchToken('quote')) {
            this.consumeToken('quote');
            let literal = '';
            while(!this.matchToken('quote')){
                if (this.matchToken('itemCount') || this.matchToken('colon') || this.matchToken('comma') || this.matchToken('semicolon') || this.matchToken('equals')) {
                    literal += this.token.value;
                    this.token = this.lexer.next();
                } else {
                    literal += this.consumeRule('Text');
                }
            }
            this.consumeToken('quote');
            annotation.value = flattenConsString(literal);
            this.consumeRule('_');
        } else {
            annotation.value = [];
            let output = '';
            while(true){
                output += this.consumeRule('Text');
                if (this.matchToken('comma')) {
                    this.consumeToken('comma');
                    this.consumeRule('_');
                    annotation.value.push(flattenConsString(output));
                    output = '';
                } else if (this.matchEndOfFile() || this.matchToken('semicolon')) {
                    annotation.value.push(flattenConsString(output));
                    break;
                }
            }
        }
        return annotation;
    },
    BracketString () {
        var _this$state;
        let output = '';
        this.consumeToken('lbrace');
        const sentenceCase = this.state.sentenceCase;
        this.state.sentenceCase = sentenceCase && this.matchToken('command');
        (_this$state = this.state).partlyLowercase && (_this$state.partlyLowercase = this.state.sentenceCase);
        while(!this.matchToken('rbrace')){
            output += this.consumeRule('Text');
        }
        const topLevel = sentenceCase && !this.state.sentenceCase;
        const protectCase = topLevel && this.state.partlyLowercase;
        this.state.sentenceCase = sentenceCase;
        this.consumeToken('rbrace');
        return protectCase ? applyFormatting(output, 'nocase') : output;
    },
    MathString () {
        let output = '';
        this.consumeToken('mathShift');
        while(!this.matchToken('mathShift')){
            if (this.matchToken('script')) {
                const script = this.consumeToken('script').value;
                const text = this.consumeRule('Text').split('');
                if (text.every((char)=>char in constants.mathScripts[script])) {
                    output += text.map((char)=>constants.mathScripts[script][char]).join('');
                } else {
                    const formatName = constants.mathScriptFormatting[script];
                    output += constants.formatting[formatName].join(text.join(''));
                }
                continue;
            }
            if (this.matchToken('command')) {
                const command = this.token.value;
                if (command in constants.mathScriptFormatting) {
                    this.consumeToken('command');
                    const text = this.consumeRule('BracketString');
                    output += applyFormatting(text, constants.mathScriptFormatting[command]);
                    continue;
                }
            }
            output += this.consumeRule('Text');
        }
        this.consumeToken('mathShift');
        return output;
    },
    Text () {
        if (this.matchToken('lbrace')) {
            return this.consumeRule('BracketString');
        } else if (this.matchToken('mathShift')) {
            return this.consumeRule('MathString');
        } else if (this.matchToken('whitespace')) {
            return this.consumeToken('whitespace').value;
        } else if (this.matchToken('commandBegin')) {
            return this.consumeRule('EnclosedEnv');
        } else if (this.matchToken('command')) {
            return this.consumeRule('Command');
        }
        const text = this.consumeToken('text').value.replace(constants.ligaturePattern, (ligature)=>constants.ligatures[ligature]);
        const afterPunctuation = this.state.afterPunctuation;
        this.state.afterPunctuation = /[?!.:]$/.test(text);
        if (!this.state.sentenceCase) {
            var _this$state2;
            (_this$state2 = this.state).partlyLowercase || (_this$state2.partlyLowercase = text === text.toLowerCase() && text !== text.toUpperCase());
            return text;
        }
        const [first, ...otherCharacters] = text;
        const rest = otherCharacters.join('');
        const restLowerCase = rest.toLowerCase();
        if (rest !== restLowerCase) {
            return text;
        }
        if (!afterPunctuation) {
            return text.toLowerCase();
        }
        return first + restLowerCase;
    },
    Command () {
        const commandToken = this.consumeToken('command');
        const command = commandToken.value;
        if (command in constants.formattingEnvs) {
            const text = this.consumeRule('Env');
            const format = constants.formattingEnvs[command];
            return applyFormatting(text, format);
        } else if (command in constants.formattingCommands) {
            const text = this.consumeRule('BracketString');
            const format = constants.formattingCommands[command];
            return applyFormatting(text, format);
        } else if (command in constants.commands) {
            return constants.commands[command];
        } else if (command in constants.mathCommands) {
            return constants.mathCommands[command];
        } else if (command in constants.diacritics && !this.matchEndOfFile()) {
            const text = this.consumeRule('Text');
            const diacritic = text[0] + constants.diacritics[command];
            return diacritic.normalize('NFC') + text.slice(1);
        } else if (command in constants.argumentCommands) {
            const func = constants.argumentCommands[command];
            const args = [];
            let arity = func.length;
            while(arity-- > 0){
                this.consumeToken('whitespace', true);
                args.push(this.consumeRule('BracketString'));
            }
            return func(...args);
        } else if (/^[&%$#_{}]$/.test(command)) {
            return commandToken.text.slice(1);
        } else {
            return commandToken.text;
        }
    },
    Env () {
        let output = '';
        while(!this.matchEndOfFile() && !this.matchToken('rbrace')){
            output += this.consumeRule('Text');
        }
        return output;
    },
    EnclosedEnv () {
        this.consumeToken('commandBegin');
        const beginEnv = this.consumeRule('BracketString');
        let output = '';
        while(!this.matchToken('commandEnd')){
            output += this.consumeRule('Text');
        }
        const end = this.consumeToken('commandEnd');
        const endEnv = this.consumeRule('BracketString');
        if (beginEnv !== endEnv) {
            throw new SyntaxError(this.lexer.formatError(end, `environment started with "${beginEnv}", ended with "${endEnv}"`));
        }
        return applyFormatting(output, constants.formattingEnvs[beginEnv]);
    },
    _ () {
        while(this.matchToken('whitespace')){
            this.consumeToken('whitespace');
        }
    }
}, {
    sentenceCase: false,
    partlyLowercase: false,
    afterPunctuation: true
});
function singleLanguageIsEnglish(language) {
    return constants.sentenceCaseLanguages.includes(language.toLowerCase());
}
function isEnglish(languages) {
    if (Array.isArray(languages)) {
        return languages.every(singleLanguageIsEnglish);
    }
    return singleLanguageIsEnglish(languages);
}
function getMainRule(fieldType, languages) {
    if (fieldType[1] === 'name') {
        return fieldType[0] === 'list' ? 'StringNames' : 'Name';
    }
    if (fieldType[1] === 'title') {
        const option = _config.default.parse.sentenceCase;
        if (option === 'always' || option === 'english' && isEnglish(languages)) {
            return 'StringTitleCase';
        } else {
            return 'String';
        }
    }
    switch(fieldType[0] === 'field' ? fieldType[1] : fieldType[0]){
        case 'list':
            return 'StringList';
        case 'separated':
            return 'StringSeparated';
        case 'verbatim':
            return 'StringVerbatim';
        case 'uri':
            return 'StringUri';
        case 'title':
        case 'literal':
        default:
            return 'String';
    }
}
function getLexerState(fieldType) {
    if (fieldType[1] === 'name') {
        return 'namesLiteral';
    }
    switch(fieldType[0]){
        case 'list':
            return 'listLiteral';
        case 'separated':
            return 'separatedLiteral';
        case 'field':
        default:
            return 'stringLiteral';
    }
}
function parse(text, field, languages = []) {
    const fieldType = constants.fieldTypes[field] || [];
    return valueGrammar.parse(lexer.reset(text, {
        state: getLexerState(fieldType),
        line: 0,
        col: 0
    }), getMainRule(fieldType, languages));
}
function parseAnnotation(text) {
    return valueGrammar.parse(lexer.reset(text, {
        state: 'annotation',
        line: 0,
        col: 0
    }), 'Annotations');
}
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib/input/entries.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parse = parse;
exports.parseBibtex = parseBibtex;
var _config = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/config.js [app-ssr] (ecmascript)"));
var _index = __turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/mapping/index.js [app-ssr] (ecmascript)");
var _value = __turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/input/value.js [app-ssr] (ecmascript)");
var _constants = __turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/input/constants.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function validate(entries, requirements) {
    const problems = [];
    for (const { type, label, properties } of entries){
        if (type in requirements) {
            const missing = [];
            for (const field of requirements[type]){
                if (Array.isArray(field) && !field.some((field)=>field in properties)) {
                    missing.push(field.join('/'));
                } else if (typeof field === 'string' && !(field in properties)) {
                    missing.push(field);
                }
            }
            if (missing.length) {
                problems.push([
                    label,
                    `missing fields: ${missing.join(', ')}`
                ]);
            }
        } else {
            problems.push([
                label,
                `invalid type: "${type}"`
            ]);
        }
    }
    if (problems.length) {
        throw new RangeError([
            'Invalid entries:'
        ].concat(problems.map(([label, problem])=>`  - ${label} has ${problem}`)).join('\n'));
    }
}
function parseEntryValues(entry) {
    const output = {};
    if ('language' in entry.properties) {
        output.language = (0, _value.parse)(entry.properties.language, 'language');
    }
    for(const property in entry.properties){
        const value = entry.properties[property];
        if (value === '') {
            continue;
        }
        output[property] = (0, _value.parse)(value + '', property, output.language);
    }
    for(const property in entry.annotations){
        for(const annotation in entry.annotations[property]){
            output[property + '+an:' + annotation] = (0, _value.parseAnnotation)(entry.annotations[property][annotation]);
        }
    }
    return _objectSpread(_objectSpread({}, entry), {}, {
        properties: output
    });
}
function parse(entries) {
    if (_config.default.parse.strict) {
        validate(entries, _constants.required.biblatex);
    }
    return (0, _index.parse)(entries.map(parseEntryValues));
}
function parseBibtex(entries) {
    if (_config.default.parse.strict) {
        validate(entries, _constants.required.bibtex);
    }
    return (0, _index.parseBibtex)(entries.map(parseEntryValues));
}
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib/input/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ref = exports.formats = void 0;
var _file = __turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/input/file.js [app-ssr] (ecmascript)");
var _bibtxt = __turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/input/bibtxt.js [app-ssr] (ecmascript)");
var _entries = __turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/input/entries.js [app-ssr] (ecmascript)");
const ref = exports.ref = '@bibtex';
const formats = exports.formats = {
    '@biblatex/text': {
        parse: _file.parse,
        parseType: {
            dataType: 'String',
            predicate: /@\s{0,5}[A-Za-z]{1,13}\s{0,5}\{\s{0,5}[^@{}"=,\\\s]{0,100}\s{0,5},[\s\S]*\}/
        }
    },
    '@biblatex/entry+object': {
        parse (input) {
            return (0, _entries.parse)([
                input
            ]);
        },
        parseType: {
            dataType: 'SimpleObject',
            propertyConstraint: {
                props: [
                    'type',
                    'label',
                    'properties'
                ]
            }
        }
    },
    '@biblatex/entries+list': {
        parse: _entries.parse,
        parseType: {
            elementConstraint: '@biblatex/entry+object'
        }
    },
    '@bibtex/text': {
        parse: _file.parse,
        outputs: '@bibtex/entries+list'
    },
    '@bibtex/entry+object': {
        parse (input) {
            return (0, _entries.parseBibtex)([
                input
            ]);
        }
    },
    '@bibtex/entries+list': {
        parse: _entries.parseBibtex
    },
    '@bibtxt/text': {
        parse: _bibtxt.parse,
        parseType: {
            dataType: 'String',
            predicate: /^\s*(\[(?!\s*[{[]).*?\]\s*(\n\s*[^[]((?!:)\S)+\s*:\s*.+?\s*)*\s*)+$/
        }
    }
};
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib/output/value.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.format = format;
exports.formatAnnotation = formatAnnotation;
var _config = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/config.js [app-ssr] (ecmascript)"));
var _constants = __turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/input/constants.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
const unicode = {};
for(const command in _constants.commands){
    unicode[_constants.commands[command]] = command;
}
for(const diacritic in _constants.diacritics){
    unicode[_constants.diacritics[diacritic]] = diacritic;
}
for(const ligature in _constants.ligatures){
    unicode[_constants.ligatures[ligature]] = ligature;
}
const mathUnicode = {};
for(const command in _constants.mathCommands){
    mathUnicode[_constants.mathCommands[command]] = command;
}
const UNSAFE_UNICODE = /[^a-zA-Z0-9\s!"'()*+,\-./:;=?@[\]\u0300-\u0308\u030a-\u030c\u0332\u0323\u0327\u0328\u0361\u0326]/g;
const DIACRITIC_PATTERN = /.[\u0300-\u0308\u030a-\u030c\u0332\u0323\u0327\u0328\u0361\u0326]+/g;
const LONE_DIACRITIC_PATTERN = /[\u0300-\u0308\u030a-\u030c\u0332\u0323\u0327\u0328\u0361\u0326]/g;
const listDelimiters = {
    separated: ',',
    list: ' and '
};
const richTextMappings = {
    i: '\\textit{',
    b: '\\textbf{',
    sc: '\\textsc{',
    sup: '\\textsuperscript{',
    sub: '\\textsubscript{',
    'span style="font-variant:small-caps;"': '\\textsc{',
    'span class="nocase"': '{'
};
function escapeCharacter(char) {
    if (char in unicode) {
        return unicode[char] in _constants.ligatures ? unicode[char] : `\\${unicode[char]}{}`;
    } else if (char in mathUnicode) {
        return `$\\${mathUnicode[char]}$`;
    } else if (/^[&%$#_{}]$/.test(char)) {
        return `\\${char}`;
    } else {
        return '';
    }
}
function escapeValue(value) {
    if (!_config.default.format.asciiOnly) {
        return value;
    }
    return value.normalize('NFKD').replace(UNSAFE_UNICODE, (char)=>escapeCharacter(char)).replace(DIACRITIC_PATTERN, (match)=>Array.from(match).reduce((subject, diacritic)=>`{\\${unicode[diacritic]} ${subject}}`)).replace(LONE_DIACRITIC_PATTERN, '');
}
function formatRichText(value) {
    const closingTags = [];
    let tokens = value.split(/<(\/?(?:i|b|sc|sup|sub|span)|span .*?)>/g);
    tokens = tokens.map((token, index)=>{
        if (index % 2 === 0) {
            return escapeValue(token);
        } else if (token in richTextMappings) {
            closingTags.push('/' + token.split(' ')[0]);
            return richTextMappings[token];
        } else if (token === closingTags[closingTags.length - 1]) {
            closingTags.pop();
            return '}';
        } else {
            return '';
        }
    });
    return tokens.join('');
}
function formatName(name) {
    if (name.family && !name.prefix && !name.given & !name.suffix) {
        return name.family.includes(listDelimiters.list) ? name.family : `{${name.family}}`;
    }
    const parts = [
        ''
    ];
    if (name.prefix && name.family) {
        parts[0] += name.prefix + ' ';
    }
    if (name.family) {
        parts[0] += name.family;
    }
    if (name.suffix) {
        parts.push(name.suffix);
        parts.push(name.given || '');
    } else {
        parts.push(name.given);
    }
    return escapeValue(parts.join(', ').trim());
}
function formatTitle(title) {
    return formatRichText(title).split(/(:\s*)/).map((part, i)=>i % 2 ? part : part.replace(/([^\\])\b([a-z]*[A-Z].*?)\b/g, '$1{$2}')).join('');
}
function formatSingleValue(value, valueType) {
    switch(valueType){
        case 'title':
            return formatTitle(value);
        case 'literal':
            return formatRichText(value.toString());
        case 'name':
            return formatName(value);
        case 'verbatim':
        case 'uri':
            return value.toString();
        default:
            return escapeValue(value.toString());
    }
}
function formatList(values, valueType, listType) {
    const delimiter = listDelimiters[listType];
    return values.map((value)=>{
        const formatted = formatSingleValue(value, valueType);
        return formatted.includes(delimiter) ? `{${formatted}}` : formatted;
    }).join(delimiter);
}
function formatAnnotationValue(values) {
    if (Array.isArray(values)) {
        return values.map((value)=>escapeValue(value).replace(/([;,"])/g, '{$1}')).join(', ');
    } else {
        return '"' + escapeValue(values).replace(/(["])/g, '{$1}') + '"';
    }
}
function format(field, value) {
    if (!(field in _constants.fieldTypes)) {
        return formatSingleValue(value, 'verbatim');
    }
    const [listType, valueType] = _constants.fieldTypes[field];
    if (listType in listDelimiters) {
        return formatList(value, valueType, listType);
    } else {
        return formatSingleValue(value, valueType);
    }
}
function formatAnnotation(value) {
    const annotations = [];
    if (value.field) {
        annotations.push('=' + formatAnnotationValue(value.field));
    }
    if (value.item) {
        for (const [itemCount, itemValue] of Object.entries(value.item)){
            if (!itemValue) {
                continue;
            }
            const i = parseInt(itemCount) + 1;
            annotations.push(i + '=' + formatAnnotationValue(itemValue));
        }
    }
    if (value.part) {
        for (const [itemCount, itemValue] of Object.entries(value.part)){
            if (!itemValue) {
                continue;
            }
            const i = parseInt(itemCount) + 1;
            for(const part in itemValue){
                if (!itemValue[part]) {
                    continue;
                }
                annotations.push(i + ':' + part + '=' + formatAnnotationValue(itemValue[part]));
            }
        }
    }
    return annotations.join('; ');
}
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib/output/entries.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.format = format;
exports.formatBibtex = formatBibtex;
var _index = __turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/mapping/index.js [app-ssr] (ecmascript)");
var _value = __turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/output/value.js [app-ssr] (ecmascript)");
function formatEntryValues({ type, label, properties }) {
    const output = {
        type,
        label,
        properties: {}
    };
    for(const property in properties){
        const value = properties[property];
        const [field, annotation] = property.split('+an:');
        if (annotation) {
            if (!output.annotations) {
                output.annotations = {};
            }
            if (!output.annotations[field]) {
                output.annotations[field] = {};
            }
            output.annotations[field][annotation] = (0, _value.formatAnnotation)(value);
        } else {
            output.properties[property] = (0, _value.format)(property, value);
        }
    }
    return output;
}
function format(entries) {
    return (0, _index.format)(entries).map(formatEntryValues);
}
function formatBibtex(entries) {
    return (0, _index.formatBibtex)(entries).map(formatEntryValues);
}
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib/output/bibtex.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.format = format;
var _config = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/config.js [app-ssr] (ecmascript)"));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
function formatField(field, value, dict) {
    return dict.listItem.join(`${field} = {${value}},`);
}
function formatEntry(entry, dict) {
    const fields = [];
    for(const field in entry.properties){
        fields.push(formatField(field, entry.properties[field], dict));
        if (entry.annotations && entry.annotations[field]) {
            for(const annotation in entry.annotations[field]){
                let annotationField = field + _config.default.biber.annotationMarker;
                if (annotation !== 'default') {
                    annotationField += _config.default.biber.namedAnnotationMarker + annotation;
                }
                fields.push(formatField(annotationField, entry.annotations[field][annotation], dict));
            }
        }
    }
    return dict.entry.join(`@${entry.type}{${entry.label},${dict.list.join(fields.join(''))}}`);
}
function format(src, dict) {
    const entries = src.map((entry)=>formatEntry(entry, dict)).join('');
    return dict.bibliographyContainer.join(entries);
}
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib/output/bibtxt.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.format = format;
function formatEntry({ type, label, properties }, dict) {
    const fields = Object.entries(properties).concat([
        [
            'type',
            type
        ]
    ]).map(([field, value])=>dict.listItem.join(`${field}: ${value}`));
    return dict.entry.join(`[${label}]${dict.list.join(fields.join(''))}`);
}
function format(src, dict) {
    const entries = src.map((entry)=>formatEntry(entry, dict)).join('\n');
    return dict.bibliographyContainer.join(entries);
}
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib/output/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _core = __turbopack_context__.r("[project]/node_modules/@citation-js/core/lib-mjs/index.js [app-ssr] (ecmascript)");
var _entries = __turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/output/entries.js [app-ssr] (ecmascript)");
var _bibtex = __turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/output/bibtex.js [app-ssr] (ecmascript)");
var _bibtxt = __turbopack_context__.r("[project]/node_modules/@citation-js/plugin-bibtex/lib/output/bibtxt.js [app-ssr] (ecmascript)");
const factory = function(mapper, formatter) {
    return function(data, opts = {}) {
        const { type, format = type || 'text' } = opts;
        data = mapper(data);
        if (format === 'object') {
            return data;
        } else if (_core.plugins.dict.has(format)) {
            return formatter(data, _core.plugins.dict.get(format), opts);
        } else {
            throw new RangeError(`Output dictionary "${format}" not available`);
        }
    };
};
var _default = exports.default = {
    bibtex: factory(_entries.formatBibtex, _bibtex.format),
    biblatex: factory(_entries.format, _bibtex.format),
    bibtxt: factory(_entries.formatBibtex, _bibtxt.format)
};
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/mapping/biblatexTypes.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"source":{"article":"article-journal","book":"book","mvbook":"book","inbook":"chapter","bookinbook":"book","booklet":"book","collection":"book","mvcollection":"book","incollection":"chapter","dataset":"dataset","manual":"report","misc":"document","online":"webpage","patent":"patent","periodical":"periodical","proceedings":"book","mvproceedings":"book","inproceedings":"paper-conference","reference":"book","mvreference":"book","inreference":"entry","report":"report","software":"software","thesis":"thesis","unpublished":"manuscript","artwork":"graphic","audio":"song","image":"figure","jurisdiction":"legal_case","legislation":"legislation","legal":"treaty","letter":"personal_communication","movie":"motion_picture","music":"musical_score","performance":"performance","review":"review","standard":"standard","video":"motion_picture","conference":"paper-conference","electronic":"webpage","mastersthesis":"thesis","phdthesis":"thesis","techreport":"report","www":"webpage"},"target":{"article":"article","article-journal":"article","article-magazine":"article","article-newspaper":"article","bill":"legislation","book":"book","broadcast":"audio","chapter":"inbook","classic":"unpublished","collection":"misc","dataset":"dataset","document":"misc","entry":"inreference","entry-dictionary":"inreference","entry-encyclopedia":"inreference","event":"misc","figure":"artwork","graphic":"artwork","hearing":"legal","interview":"audio","legal_case":"jurisdiction","legislation":"legislation","manuscript":"unpublished","motion_picture":"movie","musical_score":"music","paper-conference":"inproceedings","patent":"patent","performance":"performance","periodical":"periodical","personal_communication":"letter","post":"online","post-weblog":"online","regulation":"legal","report":"report","review":"review","review-book":"review","software":"software","song":"music","speech":"audio","standard":"standard","thesis":"thesis","treaty":"legal","webpage":"online"}});}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/mapping/bibtexTypes.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"source":{"article":"article-journal","book":"book","booklet":"book","conference":"paper-conference","inbook":"chapter","incollection":"chapter","inproceedings":"paper-conference","manual":"report","mastersthesis":"thesis","misc":"document","phdthesis":"thesis","proceedings":"book","techreport":"report","unpublished":"manuscript"},"target":{"article":"article","article-journal":"article","article-magazine":"article","article-newspaper":"article","book":"book","chapter":"inbook","manuscript":"unpublished","paper-conference":"inproceedings","report":"techreport","review":"article","review-book":"article"}});}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/input/required.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"biblatex":{"article":["author","title","journaltitle",["year","date"]],"book":["author","title",["year","date"]],"mvbook":["author","title",["year","date"]],"inbook":["author","title","booktitle",["year","date"]],"booklet":[["author","editor"],"title",["year","date"]],"collection":["editor","title",["year","date"]],"mvcollection":["editor","title",["year","date"]],"incollection":["author","title","booktitle",["year","date"]],"dataset":[["author","editor"],"title",["year","date"]],"online":[["author","editor"],"title",["year","date"],["doi","eprint","url"]],"patent":["author","title","number",["year","date"]],"periodical":["editor","title",["year","date"]],"proceedings":["title",["year","date"]],"mvproceedings":["title",["year","date"]],"inproceedings":["author","title","booktitle",["year","date"]],"report":["author","title","type","institution",["year","date"]],"thesis":["author","title","type","institution",["year","date"]],"unpublished":["author","title",["year","date"]],"conference":["author","title","booktitle",["year","date"]],"electronic":[["author","editor"],"title",["year","date"],["doi","eprint","url"]],"mastersthesis":["author","title","institution",["year","date"]],"phdthesis":["author","title","institution",["year","date"]],"techreport":["author","title","institution",["year","date"]],"www":[["author","editor"],"title",["year","date"],["doi","eprint","url"]]},"bibtex":{"article":["author","title","journal","year"],"book":[["author","editor"],"title","publisher","year"],"booklet":["title"],"inbook":[["author","editor"],"title",["chapter","pages"],"publisher","year"],"incollection":["author","title","booktitle","publisher","year"],"inproceedings":["author","title","booktitle","year"],"mastersthesis":["author","title","school","year"],"phdthesis":["author","title","school","year"],"proceedings":["title","year"],"techreport":["author","title","institution","year"],"unpublished":["author","title","note"]}});}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/input/fieldTypes.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"abstract":["field","literal"],"addendum":["field","literal"],"afterword":["list","name"],"annotation":["field","literal"],"annotator":["list","name"],"author":["list","name"],"authortype":["field","key"],"bookauthor":["list","name"],"bookpagination":["field","key"],"booksubtitle":["field","literal"],"booktitle":["field","title"],"booktitleaddon":["field","literal"],"chapter":["field","literal"],"commentator":["list","name"],"date":["field","date"],"doi":["field","verbatim"],"edition":["field","literal"],"editor":["list","name"],"editora":["list","name"],"editorb":["list","name"],"editorc":["list","name"],"editortype":["field","key"],"editoratype":["field","key"],"editorbtype":["field","key"],"editorctype":["field","key"],"eid":["field","literal"],"entrysubtype":["field","literal"],"eprint":["field","verbatim"],"eprintclass":["field","literal"],"eprinttype":["field","literal"],"eventdate":["field","date"],"eventtitle":["field","title"],"eventtitleaddon":["field","literal"],"file":["field","verbatim"],"foreword":["list","name"],"holder":["list","name"],"howpublished":["field","literal"],"indextitle":["field","literal"],"institution":["list","literal"],"introduction":["list","name"],"isan":["field","literal"],"isbn":["field","literal"],"ismn":["field","literal"],"isrn":["field","literal"],"issn":["field","literal"],"issue":["field","literal"],"issuesubtitle":["field","literal"],"issuetitle":["field","literal"],"iswc":["field","literal"],"journalsubtitle":["field","literal"],"journaltitle":["field","literal"],"label":["field","literal"],"language":["list","key"],"library":["field","literal"],"location":["list","literal"],"mainsubtitle":["field","literal"],"maintitle":["field","title"],"maintitleaddon":["field","literal"],"month":["field","literal"],"nameaddon":["field","literal"],"note":["field","literal"],"number":["field","literal"],"organization":["list","literal"],"origdate":["field","date"],"origlanguage":["list","key"],"origlocation":["list","literal"],"origpublisher":["list","literal"],"origtitle":["field","title"],"pages":["field","range"],"pagetotal":["field","literal"],"pagination":["field","key"],"part":["field","literal"],"publisher":["list","literal"],"pubstate":["field","key"],"reprinttitle":["field","literal"],"series":["field","title"],"shortauthor":["list","name"],"shorteditor":["list","name"],"shorthand":["field","literal"],"shorthandintro":["field","literal"],"shortjournal":["field","literal"],"shortseries":["field","literal"],"shorttitle":["field","title"],"subtitle":["field","literal"],"title":["field","title"],"titleaddon":["field","literal"],"translator":["list","name"],"type":["field","title"],"url":["field","uri"],"urldate":["field","date"],"venue":["field","literal"],"version":["field","literal"],"volume":["field","integer"],"volumes":["field","integer"],"year":["field","literal"],"crossref":["field","entry key"],"entryset":["separated","literal"],"execute":["field","code"],"gender":["field","gender"],"langid":["field","identifier"],"langidopts":["field","literal"],"ids":["separated","entry key"],"indexsorttitle":["field","literal"],"keywords":["separated","literal"],"options":["separated","options"],"presort":["field","string"],"related":["separated","literal"],"relatedoptions":["separated","literal"],"relatedtype":["field","identifier"],"relatedstring":["field","literal"],"sortkey":["field","literal"],"sortname":["list","name"],"sortshorthand":["field","literal"],"sorttitle":["field","literal"],"sortyear":["field","integer"],"xdata":["separated","entry key"],"xref":["field","entry key"],"namea":["list","name"],"nameb":["list","name"],"namec":["list","name"],"nameatype":["field","key"],"namebtype":["field","key"],"namectype":["field","key"],"lista":["list","literal"],"listb":["list","literal"],"listc":["list","literal"],"listd":["list","literal"],"liste":["list","literal"],"listf":["list","literal"],"usera":["field","literal"],"userb":["field","literal"],"userc":["field","literal"],"userd":["field","literal"],"usere":["field","literal"],"userf":["field","literal"],"verba":["field","literal"],"verbb":["field","literal"],"verbc":["field","literal"],"address":["list","literal"],"annote":["field","literal"],"archiveprefix":["field","literal"],"journal":["field","literal"],"key":["field","literal"],"pdf":["field","verbatim"],"primaryclass":["field","literal"],"school":["list","literal"],"numpages":["field","integer"],"pmid":["field","literal"],"pmcid":["field","literal"]});}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/input/unicode.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"diacritics":{"`":"̀","'":"́","^":"̂","~":"̃","=":"̄","u":"̆",".":"̇","\"":"̈","r":"̊","H":"̋","v":"̌","b":"̲","d":"̣","c":"̧","k":"̨","t":"͡","textcommabelow":"̦"},"commands":{"textquotesingle":"'","textasciigrave":"`","textquotedbl":"\"","textdollar":"$","textless":"<","textgreater":">","textbackslash":"\\","textasciicircum":"^","textunderscore":"_","textbraceleft":"{","textbar":"|","textbraceright":"}","textasciitilde":"~","textexclamdown":"¡","textcent":"¢","textsterling":"£","textcurrency":"¤","textyen":"¥","textbrokenbar":"¦","textsection":"§","textasciidieresis":"¨","textcopyright":"©","textordfeminine":"ª","guillemetleft":"«","guillemotleft":"«","textlnot":"¬","textregistered":"®","textasciimacron":"¯","textdegree":"°","textpm":"±","texttwosuperior":"²","textthreesuperior":"³","textasciiacute":"´","textmu":"µ","textparagraph":"¶","textperiodcentered":"·","textonesuperior":"¹","textordmasculine":"º","guillemetright":"»","guillemotright":"»","textonequarter":"¼","textonehalf":"½","textthreequarters":"¾","textquestiondown":"¿","AE":"Æ","DH":"Ð","texttimes":"×","O":"Ø","TH":"Þ","ss":"ß","ae":"æ","dh":"ð","textdiv":"÷","o":"ø","th":"þ","DJ":"Đ","dj":"đ","i":"ı","IJ":"Ĳ","ij":"ĳ","L":"Ł","l":"ł","NG":"Ŋ","ng":"ŋ","OE":"Œ","oe":"œ","textflorin":"ƒ","j":"ȷ","textasciicaron":"ˇ","textasciibreve":"˘","textacutedbl":"˝","textgravedbl":"˵","texttildelow":"˷","textbaht":"฿","SS":"ẞ","textcompwordmark":"‌","textendash":"–","textemdash":"—","textbardbl":"‖","textquoteleft":"‘","textquoteright":"’","quotesinglbase":"‚","textquotedblleft":"“","textquotedblright":"”","quotedblbase":"„","textdagger":"†","textdaggerdbl":"‡","textbullet":"•","textellipsis":"…","textperthousand":"‰","textpertenthousand":"‱","guilsinglleft":"‹","guilsinglright":"›","textreferencemark":"※","textinterrobang":"‽","textfractionsolidus":"⁄","textlquill":"⁅","textrquill":"⁆","textdiscount":"⁒","textcolonmonetary":"₡","textlira":"₤","textnaira":"₦","textwon":"₩","textdong":"₫","texteuro":"€","textpeso":"₱","textcelsius":"℃","textnumero":"№","textcircledP":"℗","textrecipe":"℞","textservicemark":"℠","texttrademark":"™","textohm":"Ω","textmho":"℧","textestimated":"℮","textleftarrow":"←","textuparrow":"↑","textrightarrow":"→","textdownarrow":"↓","textminus":"−","Hwithstroke":"Ħ","hwithstroke":"ħ","textasteriskcentered":"∗","textsurd":"√","textlangle":"〈","textrangle":"〉","textblank":"␢","textvisiblespace":"␣","textopenbullet":"◦","textbigcircle":"◯","textmusicalnote":"♪","textmarried":"⚭","textdivorced":"⚮","textinterrobangdown":"⸘","textcommabelow":null,"copyright":"©"},"mathCommands":{"Gamma":"Γ","Delta":"Δ","Theta":"Θ","Lambda":"Λ","Xi":"Ξ","Pi":"Π","Sigma":"Σ","Phi":"Φ","Psi":"Ψ","Omega":"Ω","alpha":"α","beta":"β","gamma":"γ","delta":"δ","varepsilon":"ε","zeta":"ζ","eta":"η","theta":"θ","iota":"ι","kappa":"κ","lambda":"λ","mu":"μ","nu":"ν","xi":"ξ","pi":"π","rho":"ρ","varsigma":"ς","sigma":"σ","tau":"τ","upsilon":"υ","varphi":"φ","chi":"χ","psi":"ψ","omega":"ω","vartheta":"ϑ","Upsilon":"ϒ","phi":"ϕ","varpi":"ϖ","varrho":"ϱ","epsilon":"ϵ"}});}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/input/constants.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "argumentCommands",
    ()=>argumentCommands,
    "commands",
    ()=>commands,
    "defaultStrings",
    ()=>defaultStrings,
    "diacritics",
    ()=>diacritics,
    "fieldTypes",
    ()=>fieldTypes,
    "formatting",
    ()=>formatting,
    "formattingCommands",
    ()=>formattingCommands,
    "formattingEnvs",
    ()=>formattingEnvs,
    "ligaturePattern",
    ()=>ligaturePattern,
    "ligatures",
    ()=>ligatures,
    "mathCommands",
    ()=>mathCommands,
    "mathScriptFormatting",
    ()=>mathScriptFormatting,
    "mathScripts",
    ()=>mathScripts,
    "required",
    ()=>required,
    "sentenceCaseLanguages",
    ()=>sentenceCaseLanguages
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$required$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/input/required.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$fieldTypes$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/input/fieldTypes.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$unicode$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/input/unicode.json (json)");
;
;
;
const required = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$required$2e$json__$28$json$29$__["default"];
const fieldTypes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$fieldTypes$2e$json__$28$json$29$__["default"];
const diacritics = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$unicode$2e$json__$28$json$29$__["default"].diacritics;
const commands = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$unicode$2e$json__$28$json$29$__["default"].commands;
const mathCommands = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$unicode$2e$json__$28$json$29$__["default"].mathCommands;
const defaultStrings = {
    jan: '01',
    feb: '02',
    mar: '03',
    apr: '04',
    may: '05',
    jun: '06',
    jul: '07',
    aug: '08',
    sep: '09',
    oct: '10',
    nov: '11',
    dec: '12',
    acmcs: 'ACM Computing Surveys',
    acta: 'Acta Informatica',
    cacm: 'Communications of the ACM',
    ibmjrd: 'IBM Journal of Research and Development',
    ibmsj: 'IBM Systems Journal',
    ieeese: 'IEEE Transactions on Software Engineering',
    ieeetc: 'IEEE Transactions on Computers',
    ieeetcad: 'IEEE Transactions on Computer-Aided Design of Integrated Circuits',
    ipl: 'Information Processing Letters',
    jacm: 'Journal of the ACM',
    jcss: 'Journal of Computer and System Sciences',
    scp: 'Science of Computer Programming',
    sicomp: 'SIAM Journal on Computing',
    tocs: 'ACM Transactions on Computer Systems',
    tods: 'ACM Transactions on Database Systems',
    tog: 'ACM Transactions on Graphics',
    toms: 'ACM Transactions on Mathematical Software',
    toois: 'ACM Transactions on Office Information Systems',
    toplas: 'ACM Transactions on Programming Languages and Systems',
    tcs: 'Theoretical Computer Science'
};
const formattingEnvs = {
    it: 'italics',
    itshape: 'italics',
    sl: 'italics',
    slshape: 'italics',
    em: 'italics',
    bf: 'bold',
    bfseries: 'bold',
    sc: 'smallcaps',
    scshape: 'smallcaps',
    rm: undefined,
    sf: undefined,
    tt: undefined
};
const formattingCommands = {
    textit: 'italics',
    textsl: 'italics',
    emph: 'italics',
    mkbibitalic: 'italics',
    mkbibemph: 'italics',
    textbf: 'bold',
    strong: 'bold',
    mkbibbold: 'bold',
    textsc: 'smallcaps',
    textsuperscript: 'superscript',
    textsubscript: 'subscript',
    enquote: 'quotes',
    mkbibquote: 'quotes',
    textmd: undefined,
    textrm: undefined,
    textsf: undefined,
    texttt: undefined,
    textup: undefined
};
const formatting = {
    italics: [
        '<i>',
        '</i>'
    ],
    bold: [
        '<b>',
        '</b>'
    ],
    superscript: [
        '<sup>',
        '</sup>'
    ],
    subscript: [
        '<sub>',
        '</sub>'
    ],
    smallcaps: [
        '<span style="font-variant:small-caps;">',
        '</span>'
    ],
    nocase: [
        '<span class="nocase">',
        '</span>'
    ],
    quotes: [
        '\u201C',
        '\u201D'
    ]
};
const argumentCommands = {
    ElsevierGlyph (glyph) {
        return String.fromCharCode(parseInt(glyph, 16));
    },
    href (url, text) {
        return url;
    },
    url (url) {
        return url;
    }
};
const ligaturePattern = /---?|''|``|~/g;
const ligatures = {
    '--': '\u2013',
    '---': '\u2014',
    '``': '\u201C',
    "''": '\u201D',
    '~': '\u00A0'
};
const mathScriptFormatting = {
    '^': 'superscript',
    sp: 'superscript',
    _: 'subscript',
    sb: 'subscript',
    mathrm: undefined
};
const mathScripts = {
    '^': {
        '0': '\u2070',
        '1': '\u00B9',
        '2': '\u00B2',
        '3': '\u00B3',
        '4': '\u2074',
        '5': '\u2075',
        '6': '\u2076',
        '7': '\u2077',
        '8': '\u2078',
        '9': '\u2079',
        '+': '\u207A',
        '-': '\u207B',
        '=': '\u207C',
        '(': '\u207D',
        ')': '\u207E',
        'i': '\u2071',
        'n': '\u207F'
    },
    '_': {
        '0': '\u2080',
        '1': '\u2081',
        '2': '\u2082',
        '3': '\u2083',
        '4': '\u2084',
        '5': '\u2085',
        '6': '\u2086',
        '7': '\u2087',
        '8': '\u2088',
        '9': '\u2089',
        '+': '\u208A',
        '-': '\u208B',
        '=': '\u208C',
        '(': '\u208D',
        ')': '\u208E',
        'a': '\u2090',
        'e': '\u2091',
        'o': '\u2092',
        'x': '\u2093',
        '\u0259': '\u2094',
        'h': '\u2095',
        'k': '\u2096',
        'l': '\u2097',
        'm': '\u2098',
        'n': '\u2099',
        's': '\u209A',
        'p': '\u209B',
        't': '\u209C'
    }
};
const sentenceCaseLanguages = [
    'american',
    'british',
    'canadian',
    'english',
    'australian',
    'newzealand',
    'usenglish',
    'ukenglish',
    'en',
    'eng',
    'en-au',
    'en-bz',
    'en-ca',
    'en-cb',
    'en-gb',
    'en-ie',
    'en-jm',
    'en-nz',
    'en-ph',
    'en-tt',
    'en-us',
    'en-za',
    'en-zw',
    'anglais'
];
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/config.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$biblatexTypes$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/mapping/biblatexTypes.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$bibtexTypes$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/mapping/bibtexTypes.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/input/constants.js [app-ssr] (ecmascript)");
;
;
;
const __TURBOPACK__default__export__ = {
    constants: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__,
    types: {
        biblatex: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$biblatexTypes$2e$json__$28$json$29$__["default"],
        bibtex: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$bibtexTypes$2e$json__$28$json$29$__["default"]
    },
    parse: {
        biblatex: true,
        strict: false,
        sentenceCase: 'never'
    },
    format: {
        useIdAsLabel: false,
        checkLabel: true,
        asciiOnly: true
    },
    biber: {
        annotationMarker: '+an',
        namedAnnotationMarker: ':'
    }
};
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/input/file.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "bibtexGrammar",
    ()=>bibtexGrammar,
    "parse",
    ()=>parse
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$core$2f$lib$2d$mjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/core/lib-mjs/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$core$2f$lib$2d$mjs$2f$util$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/core/lib-mjs/util/index.js [app-ssr] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$core$2f$lib$2d$mjs$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__logger$3e$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/core/lib-mjs/logger.js [app-ssr] (ecmascript) <export default as logger>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$moo$2f$moo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/moo/moo.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/config.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/input/constants.js [app-ssr] (ecmascript)");
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
;
;
;
;
const identifier = /[a-zA-Z_][a-zA-Z0-9_:+-]*/;
const whitespace = {
    comment: /%.*/,
    whitespace: {
        match: /\s+/,
        lineBreaks: true
    }
};
const lexer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$moo$2f$moo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].states({
    main: {
        junk: {
            match: /@[cC][oO][mM][mM][eE][nN][tT].+|[^@]+/,
            lineBreaks: true
        },
        at: {
            match: '@',
            push: 'entry'
        }
    },
    entry: _objectSpread(_objectSpread({}, whitespace), {}, {
        otherEntryType: {
            match: /[sS][tT][rR][iI][nN][gG]|[pP][rR][eE][aA][mM][bB][lL][eE]/,
            next: 'otherEntryContents'
        },
        dataEntryType: {
            match: identifier,
            next: 'dataEntryContents'
        }
    }),
    otherEntryContents: _objectSpread(_objectSpread({}, whitespace), {}, {
        lbrace: {
            match: /[{(]/,
            next: 'fields'
        }
    }),
    dataEntryContents: _objectSpread(_objectSpread({}, whitespace), {}, {
        lbrace: {
            match: /[{(]/,
            next: 'dataEntryContents'
        },
        label: /[^,\s]+/,
        comma: {
            match: ',',
            next: 'fields'
        }
    }),
    fields: _objectSpread(_objectSpread({}, whitespace), {}, {
        identifier,
        number: /-?\d+/,
        hash: '#',
        equals: '=',
        comma: ',',
        quote: {
            match: '"',
            push: 'quotedLiteral'
        },
        lbrace: {
            match: '{',
            push: 'bracedLiteral'
        },
        rbrace: {
            match: /[})]/,
            pop: true
        }
    }),
    quotedLiteral: {
        lbrace: {
            match: '{',
            push: 'bracedLiteral'
        },
        quote: {
            match: '"',
            pop: true
        },
        text: {
            match: /(?:\\[\\{]|[^{"])+/,
            lineBreaks: true
        }
    },
    bracedLiteral: {
        lbrace: {
            match: '{',
            push: 'bracedLiteral'
        },
        rbrace: {
            match: '}',
            pop: true
        },
        text: {
            match: /(?:\\[\\{}]|[^{}])+/,
            lineBreaks: true
        }
    }
});
const delimiters = {
    '(': ')',
    '{': '}'
};
const bibtexGrammar = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$core$2f$lib$2d$mjs$2f$util$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].Grammar({
    Main () {
        const entries = [];
        while(true){
            while(this.matchToken('junk')){
                this.consumeToken('junk');
            }
            if (this.matchEndOfFile()) {
                break;
            }
            entries.push(this.consumeRule('Entry'));
        }
        return entries.filter(Boolean);
    },
    _ () {
        let oldToken;
        while(oldToken !== this.token){
            oldToken = this.token;
            this.consumeToken('whitespace', true);
            this.consumeToken('comment', true);
        }
    },
    Entry () {
        this.consumeToken('at');
        this.consumeRule('_');
        const type = (this.matchToken('otherEntryType') ? this.consumeToken('otherEntryType') : this.consumeToken('dataEntryType')).value.toLowerCase();
        this.consumeRule('_');
        const openBrace = this.consumeToken('lbrace').value;
        this.consumeRule('_');
        let result;
        if (type === 'string') {
            const [key, value] = this.consumeRule('Field');
            this.state.strings[key] = value;
        } else if (type === 'preamble') {
            this.consumeRule('Expression');
        } else {
            const label = this.consumeToken('label').value;
            this.consumeRule('_');
            this.consumeToken('comma');
            this.consumeRule('_');
            const entryBody = this.consumeRule('EntryBody');
            result = _objectSpread({
                type,
                label
            }, entryBody);
        }
        this.consumeRule('_');
        const closeBrace = this.consumeToken('rbrace').value;
        if (closeBrace !== delimiters[openBrace]) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$core$2f$lib$2d$mjs$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__logger$3e$__["logger"].warn('[plugin-bibtex]', `entry started with "${openBrace}", but ends with "${closeBrace}"`);
        }
        return result;
    },
    EntryBody () {
        const output = {
            properties: {}
        };
        while(this.matchToken('identifier')){
            const [field, value] = this.consumeRule('Field');
            let annotationField;
            let annotationName = 'default';
            if (field.endsWith(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].biber.annotationMarker)) {
                annotationField = field.slice(0, -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].biber.annotationMarker.length);
            } else if (field.includes(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].biber.annotationMarker + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].biber.namedAnnotationMarker)) {
                [annotationField, annotationName] = field.split(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].biber.annotationMarker + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].biber.namedAnnotationMarker);
            }
            if (annotationField) {
                if (!output.annotations) {
                    output.annotations = {};
                }
                if (!output.annotations[annotationField]) {
                    output.annotations[annotationField] = {};
                }
                output.annotations[annotationField][annotationName] = value;
            } else {
                output.properties[field] = value;
            }
            this.consumeRule('_');
            if (this.consumeToken('comma', true)) {
                this.consumeRule('_');
            } else {
                break;
            }
        }
        return output;
    },
    Field () {
        const field = this.consumeToken('identifier').value.toLowerCase();
        this.consumeRule('_');
        this.consumeToken('equals');
        this.consumeRule('_');
        const value = this.consumeRule('Expression');
        return [
            field,
            value
        ];
    },
    Expression () {
        let output = this.consumeRule('ExpressionPart');
        this.consumeRule('_');
        while(this.matchToken('hash')){
            this.consumeToken('hash');
            this.consumeRule('_');
            output += this.consumeRule('ExpressionPart').toString();
            this.consumeRule('_');
        }
        return output;
    },
    ExpressionPart () {
        if (this.matchToken('identifier')) {
            return this.state.strings[this.consumeToken('identifier').value.toLowerCase()] || '';
        } else if (this.matchToken('number')) {
            return parseInt(this.consumeToken('number'));
        } else if (this.matchToken('quote')) {
            return this.consumeRule('QuoteString');
        } else {
            return this.consumeRule('BracketString');
        }
    },
    QuoteString () {
        let output = '';
        this.consumeToken('quote');
        while(!this.matchToken('quote')){
            output += this.consumeRule('Text');
        }
        this.consumeToken('quote');
        return output;
    },
    BracketString () {
        let output = '';
        this.consumeToken('lbrace');
        while(!this.matchToken('rbrace')){
            output += this.consumeRule('Text');
        }
        this.consumeToken('rbrace');
        return output;
    },
    Text () {
        if (this.matchToken('lbrace')) {
            return `{${this.consumeRule('BracketString')}}`;
        } else {
            return this.consumeToken('text').value;
        }
    }
}, {
    strings: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["defaultStrings"]
});
function parse(text) {
    return bibtexGrammar.parse(lexer.reset(text));
}
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/input/bibtxt.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "parse",
    ()=>parseBibTxt,
    "text",
    ()=>parseBibTxt,
    "textEntry",
    ()=>parseBibTxtEntry
]);
const bibTxtRegex = {
    splitEntries: /\n\s*(?=\[)/g,
    parseEntry: /^\[(.+?)\]\s*(?:\n([\s\S]+))?$/,
    splitPairs: /((?=.)\s)*\n\s*/g,
    splitPair: /:(.*)/
};
const parseBibTxtEntry = (entry)=>{
    const [, label, pairs] = entry.match(bibTxtRegex.parseEntry) || [];
    if (!label || !pairs) {
        return {};
    } else {
        const out = {
            type: 'book',
            label,
            properties: {}
        };
        pairs.trim().split(bibTxtRegex.splitPairs).filter((v)=>v).forEach((pair)=>{
            let [key, value] = pair.split(bibTxtRegex.splitPair);
            if (value) {
                key = key.trim();
                value = value.trim();
                if (key === 'type') {
                    out.type = value;
                } else {
                    out.properties[key] = value;
                }
            }
        });
        return out;
    }
};
const parseBibTxt = (src)=>src.trim().split(bibTxtRegex.splitEntries).map(parseBibTxtEntry);
;
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/mapping/shared.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Converters",
    ()=>Converters,
    "LABEL",
    ()=>LABEL,
    "MONTHS",
    ()=>MONTHS,
    "STANDARD_NUMBERS_PATTERN",
    ()=>STANDARD_NUMBERS_PATTERN,
    "TYPE",
    ()=>TYPE,
    "TYPE_KEYS",
    ()=>TYPE_KEYS,
    "formatLabel",
    ()=>formatLabel,
    "parseDate",
    ()=>parseDate,
    "parseMonth",
    ()=>parseMonth
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$core$2f$lib$2d$mjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/core/lib-mjs/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$core$2f$lib$2d$mjs$2f$util$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/core/lib-mjs/util/index.js [app-ssr] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/config.js [app-ssr] (ecmascript)");
;
;
const stopWords = new Set([
    'the',
    'a',
    'an'
]);
const unsafeChars = /(?:<\/?.*?>|[\u0020-\u002F\u003A-\u0040\u005B-\u005E\u0060\u007B-\u007F])+/g;
const unicode = /[^\u0020-\u007F]+/g;
function isLabelSafe(text) {
    return !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].format.checkLabel || !text.match(unsafeChars);
}
function formatLabelFromId(id) {
    if (id === null) {
        return 'null';
    } else if (id === undefined) {
        return 'undefined';
    } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].format.checkLabel) {
        return id.toString().replace(unsafeChars, '');
    } else {
        return id.toString();
    }
}
function firstWord(text) {
    if (!text) {
        return '';
    } else {
        return text.normalize('NFKD').replace(unicode, '').split(unsafeChars).find((word)=>word.length && !stopWords.has(word.toLowerCase()));
    }
}
const name = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$core$2f$lib$2d$mjs$2f$util$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].Translator([
    {
        source: 'given',
        target: 'given'
    },
    {
        source: 'family',
        target: 'family'
    },
    {
        source: 'suffix',
        target: 'suffix'
    },
    {
        source: 'prefix',
        target: 'non-dropping-particle'
    },
    {
        source: 'family',
        target: 'literal',
        when: {
            source: false,
            target: {
                family: false,
                given: false
            }
        }
    }
]);
const months = [
    'jan',
    'feb',
    'mar',
    'apr',
    'may',
    'jun',
    'jul',
    'aug',
    'sep',
    'oct',
    'nov',
    'dec'
];
const TYPE = 'BibTeX type';
const LABEL = 'BibTeX label';
const MONTHS = {
    jan: 1,
    feb: 2,
    mar: 3,
    apr: 4,
    may: 5,
    jun: 6,
    jul: 7,
    aug: 8,
    sep: 9,
    oct: 10,
    nov: 11,
    dec: 12,
    january: 1,
    february: 2,
    march: 3,
    april: 4,
    may: 5,
    june: 6,
    july: 7,
    august: 8,
    september: 9,
    october: 10,
    november: 11,
    december: 12
};
const TYPE_KEYS = {
    bathesis: 'Bachelor\'s thesis',
    mathesis: 'Master\'s thesis',
    phdthesis: 'PhD thesis',
    candthesis: 'Candidate thesis',
    techreport: 'technical report',
    resreport: 'research report',
    software: 'computer software',
    datacd: 'data cd',
    audiocd: 'audio cd',
    patent: 'patent',
    patentde: 'German patent',
    patenteu: 'European patent',
    patentfr: 'French patent',
    patentuk: 'British patent',
    patentus: 'U.S. patent',
    patreq: 'patent request',
    patreqde: 'German patent request',
    patreqeu: 'European patent request',
    patreqfr: 'French patent request',
    patrequk: 'British patent request',
    patrequs: 'U.S. patent request'
};
const STANDARD_NUMBERS_PATTERN = /(^(?:ISAN )?(?:[0-9a-f]{4}-){4}[0-9a-z](?:-(?:[0-9a-f]{4}-){2}[0-9a-z])?$)|(^(?:979-?0-?|M-?)(?:\d{9}|(?=[\d-]{11}$)\d+-\d+-\d)$)|(^ISRN .{1,36}$)|(^(?:ISWC )?T-?\d{9}-?\d$)/i;
function parseDate(date) {
    const parts = date.split('T')[0].replace(/[?~%]$/, '').split('-');
    const year = +parts[0].replace(/^Y(?=-?\d{4}\d+)/, '').replace(/X/g, '0');
    const month = +parts[1];
    const day = +parts[2];
    if (!month || month > 20) {
        return [
            year
        ];
    } else if (!day) {
        return [
            year,
            month
        ];
    } else {
        return [
            year,
            month,
            day
        ];
    }
}
function parseMonth(value) {
    if (value == null) {
        return [];
    }
    if (+value) {
        return [
            parseInt(value, 10)
        ];
    }
    value = value.trim().toLowerCase();
    if (value in MONTHS) {
        return [
            MONTHS[value]
        ];
    }
    const parts = value.split(/\s+/);
    let month;
    let day;
    if (parts[0] in MONTHS) {
        month = MONTHS[parts[0]];
        day = parseInt(parts[1]);
    } else if (parts[1] in MONTHS) {
        month = MONTHS[parts[1]];
        day = parseInt(parts[0]);
    }
    return day ? [
        month,
        day
    ] : month ? [
        month
    ] : [];
}
function formatLabel(author, issued, suffix, title) {
    let label = '';
    if (author && author[0]) {
        label += firstWord(author[0].family || author[0].literal);
    }
    if (issued && issued['date-parts'] && issued['date-parts'][0]) {
        label += issued['date-parts'][0][0];
    }
    if (suffix) {
        label += suffix;
    } else if (title) {
        label += firstWord(title);
    }
    return label;
}
const Converters = {
    PICK: {
        toTarget (...args) {
            return args.find(Boolean);
        },
        toSource (value) {
            return [
                value
            ];
        }
    },
    DATE: {
        toTarget (date) {
            const parts = date.split('/').map((part)=>part && part !== '..' ? parseDate(part) : undefined);
            return isNaN(parts[0][0]) ? {
                literal: date
            } : {
                'date-parts': parts
            };
        },
        toSource (date) {
            if ('date-parts' in date) {
                return date['date-parts'].map((datePart)=>datePart.map((datePart)=>datePart.toString().padStart(2, '0')).join('-')).join('/');
            }
        }
    },
    YEAR_MONTH: {
        toTarget (year, month, day) {
            if (isNaN(+year)) {
                return {
                    literal: year
                };
            } else if (!isNaN(+day) && !isNaN(+month)) {
                return {
                    'date-parts': [
                        [
                            +year,
                            +month,
                            +day
                        ]
                    ]
                };
            } else {
                return {
                    'date-parts': [
                        [
                            +year,
                            ...parseMonth(month)
                        ]
                    ]
                };
            }
        },
        toSource (date) {
            if ('date-parts' in date) {
                const [year, month, day] = date['date-parts'][0];
                return [
                    year.toString(),
                    month ? day ? `${months[month - 1]} ${day}` : month : undefined
                ];
            } else {
                return [];
            }
        }
    },
    EPRINT: {
        toTarget (id, type) {
            if (type === 'pubmed') {
                return id;
            }
        },
        toSource (id) {
            return [
                id,
                'pubmed'
            ];
        }
    },
    EVENT_TITLE: {
        toTarget (title, addon) {
            if (addon) {
                title += ' (' + addon + ')';
            }
            return title;
        },
        toSource (title) {
            return title.match(/^(.+)(?: \((.+)\))?$/).slice(1, 3);
        }
    },
    HOW_PUBLISHED: {
        toTarget (howPublished) {
            if (howPublished.startsWith('http')) {
                return howPublished;
            }
        }
    },
    KEYWORDS: {
        toTarget (list) {
            return list.join(',');
        },
        toSource (list) {
            return list.split(',');
        }
    },
    LABEL: {
        toTarget (label) {
            return [
                label,
                label
            ];
        },
        toSource (id, label, author, issued, suffix, title) {
            if (label && isLabelSafe(label)) {
                return label;
            } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].format.useIdAsLabel) {
                return formatLabelFromId(id);
            } else {
                return formatLabel(author, issued, suffix, title) || formatLabelFromId(id);
            }
        }
    },
    NAMES: {
        toTarget (list) {
            return list.map(name.convertToTarget);
        },
        toSource (list) {
            return list.map(name.convertToSource);
        }
    },
    NAMES_ORCID: {
        toTarget (list, orcid) {
            return list.map((inputName, i)=>{
                var _orcid$item;
                const outputName = name.convertToTarget(inputName);
                if (typeof (orcid === null || orcid === void 0 || (_orcid$item = orcid.item) === null || _orcid$item === void 0 ? void 0 : _orcid$item[i]) === 'string') {
                    outputName._orcid = orcid.item[i];
                }
                return outputName;
            });
        },
        toSource (list) {
            const names = [];
            const orcid = [];
            for(let i = 0; i < list.length; i++){
                names.push(name.convertToSource(list[i]));
                if (list[i]._orcid) {
                    orcid[i] = list[i]._orcid;
                }
            }
            return [
                names,
                orcid.length ? {
                    item: orcid
                } : undefined
            ];
        }
    },
    PAGES: {
        toTarget (pages) {
            return pages.replace(/[–—]/, '-');
        },
        toSource (pages) {
            return pages.replace('-', '--');
        }
    },
    STANDARD_NUMBERS: {
        toTarget (...args) {
            return args.find(Boolean);
        },
        toSource (number) {
            const match = number.toString().match(STANDARD_NUMBERS_PATTERN);
            return match ? match.slice(1, 5) : [];
        }
    },
    STATUS: {
        toSource (state) {
            if (/^(inpreparation|submitted|forthcoming|inpress|prepublished)$/i.test(state)) {
                return state;
            }
        }
    },
    TITLE: {
        toTarget (title, subtitle, addon) {
            if (subtitle) {
                title += ': ' + subtitle;
            }
            return title;
        },
        toSource (title) {
            return [
                title
            ];
        }
    }
};
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/mapping/biblatex.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$core$2f$lib$2d$mjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/core/lib-mjs/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$core$2f$lib$2d$mjs$2f$util$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/core/lib-mjs/util/index.js [app-ssr] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$date$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/date/lib/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$biblatexTypes$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/mapping/biblatexTypes.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/mapping/shared.js [app-ssr] (ecmascript)");
;
;
;
;
const nonSpec = [
    {
        source: 'note',
        target: 'accessed',
        when: {
            source: false,
            target: {
                note: false,
                addendum: false
            }
        },
        convert: {
            toSource (accessed) {
                return `[Online; accessed ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$date$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(accessed)}]`;
            }
        }
    },
    {
        source: 'numpages',
        target: 'number-of-pages',
        when: {
            source: {
                pagetotal: false
            },
            target: false
        }
    },
    {
        source: 'pmid',
        target: 'PMID',
        when: {
            source: {
                eprinttype (type) {
                    return type !== 'pmid';
                },
                archiveprefix (type) {
                    return type !== 'pmid';
                }
            },
            target: false
        }
    },
    {
        source: 'pmcid',
        target: 'PMCID',
        when: {
            target: false
        }
    },
    {
        source: 's2id',
        target: 'custom',
        convert: {
            toTarget (S2ID) {
                return {
                    S2ID
                };
            },
            toSource ({ S2ID }) {
                return S2ID;
            }
        }
    }
];
const aliases = [
    {
        source: 'annote',
        target: 'annote',
        when: {
            source: {
                annotation: false
            },
            target: false
        }
    },
    {
        source: 'address',
        target: 'publisher-place',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].PICK,
        when: {
            source: {
                location: false
            },
            target: false
        }
    },
    {
        source: [
            'eprint',
            'archiveprefix'
        ],
        target: 'PMID',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].EPRINT,
        when: {
            source: {
                eprinttype: false
            },
            target: false
        }
    },
    {
        source: 'journal',
        target: 'container-title',
        when: {
            source: {
                maintitle: false,
                booktitle: false,
                journaltitle: false
            },
            target: false
        }
    },
    {
        source: 'school',
        target: 'publisher',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].PICK,
        when: {
            source: {
                institution: false,
                organization: false,
                publisher: false
            },
            target: false
        }
    }
];
const __TURBOPACK__default__export__ = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$core$2f$lib$2d$mjs$2f$util$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].Translator([
    ...aliases,
    ...nonSpec,
    {
        source: 'abstract',
        target: 'abstract'
    },
    {
        source: 'urldate',
        target: 'accessed',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].DATE
    },
    {
        source: 'annotation',
        target: 'annote'
    },
    {
        source: [
            'author',
            'author+an:orcid'
        ],
        target: 'author',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].NAMES_ORCID
    },
    {
        source: 'library',
        target: 'call-number'
    },
    {
        source: 'chapter',
        target: 'chapter-number'
    },
    {
        source: 'bookauthor',
        target: 'container-author',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].NAMES
    },
    {
        source: [
            'maintitle',
            'mainsubtitle',
            'maintitleaddon'
        ],
        target: 'container-title',
        when: {
            source: true,
            target: {
                'number-of-volumes': true
            }
        },
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].TITLE
    },
    {
        source: [
            'booktitle',
            'booksubtitle',
            'booktitleaddon'
        ],
        target: 'container-title',
        when: {
            source: {
                maintitle: false
            },
            target: {
                'number-of-volumes': false,
                type (type) {
                    return !type || !type.startsWith('article');
                }
            }
        },
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].TITLE
    },
    {
        source: [
            'journaltitle',
            'journalsubtitle',
            'journaltitleaddon'
        ],
        target: 'container-title',
        when: {
            source: {
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TYPE"]]: 'article'
            },
            target: {
                type: [
                    'article',
                    'article-newspaper',
                    'article-journal',
                    'article-magazine'
                ]
            }
        },
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].TITLE
    },
    {
        source: 'shortjournal',
        target: 'container-title-short',
        when: {
            source: {
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TYPE"]]: 'article'
            },
            target: {
                type: [
                    'article',
                    'article-newspaper',
                    'article-journal',
                    'article-magazine'
                ]
            }
        }
    },
    {
        source: 'shortjournal',
        target: 'journalAbbreviation',
        when: {
            source: false,
            target: {
                'container-title-short': false
            }
        }
    },
    {
        source: 'number',
        target: 'collection-number',
        when: {
            source: {
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TYPE"]]: [
                    'book',
                    'mvbook',
                    'inbook',
                    'bookinbook',
                    'suppbook',
                    'collection',
                    'mvcollection',
                    'incollection',
                    'suppcollection',
                    'manual',
                    'suppperiodical',
                    'proceedings',
                    'mvproceedings',
                    'refererence'
                ]
            },
            target: {
                type: [
                    'bill',
                    'book',
                    'broadcast',
                    'chapter',
                    'dataset',
                    'entry',
                    'entry-dictionary',
                    'entry-encyclopedia',
                    'figure',
                    'graphic',
                    'interview',
                    'legislation',
                    'legal_case',
                    'manuscript',
                    'map',
                    'motion_picture',
                    'musical_score',
                    'pamphlet',
                    'post',
                    'post-weblog',
                    'personal_communication',
                    'review',
                    'review-book',
                    'song',
                    'speech',
                    'thesis',
                    'treaty',
                    'webpage'
                ]
            }
        }
    },
    {
        source: 'series',
        target: 'collection-title'
    },
    {
        source: 'shortseries',
        target: 'collection-title-short'
    },
    {
        source: 'doi',
        target: 'DOI'
    },
    {
        source: 'edition',
        target: 'edition'
    },
    {
        source: 'editor',
        target: 'editor',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].NAMES
    },
    {
        source: [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TYPE"],
            'entrysubtype',
            'type'
        ],
        target: [
            'type',
            'genre'
        ],
        convert: {
            toTarget (type, subtype, typeKey) {
                if (!typeKey) {
                    if (type === 'mastersthesis') {
                        typeKey = 'mathesis';
                    }
                    if (type === 'phdthesis') {
                        typeKey = 'phdthesis';
                    }
                    if (type === 'techreport') {
                        typeKey = 'techreport';
                    }
                }
                return [
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$biblatexTypes$2e$json__$28$json$29$__["default"].source[type] || 'document',
                    typeKey || subtype
                ];
            },
            toSource (type, genre) {
                const sourceType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$biblatexTypes$2e$json__$28$json$29$__["default"].target[type] || 'misc';
                return genre in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TYPE_KEYS"] ? [
                    sourceType,
                    undefined,
                    genre
                ] : [
                    sourceType,
                    genre
                ];
            }
        }
    },
    {
        source: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TYPE"],
        when: {
            target: {
                type: false
            }
        },
        convert: {
            toSource () {
                return 'misc';
            }
        }
    },
    {
        source: 'eventdate',
        target: 'event-date',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].DATE
    },
    {
        source: 'venue',
        target: 'event-place'
    },
    {
        source: [
            'eventtitle',
            'eventtitleaddon'
        ],
        target: 'event-title',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].EVENT_TITLE
    },
    {
        source: [
            'eventtitle',
            'eventtitleaddon'
        ],
        target: 'event',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].EVENT_TITLE,
        when: {
            source: false,
            target: {
                'event-title': false
            }
        }
    },
    {
        source: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LABEL"],
        target: [
            'id',
            'citation-key',
            'author',
            'issued',
            'year-suffix',
            'title'
        ],
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].LABEL
    },
    {
        source: 'isbn',
        target: 'ISBN'
    },
    {
        source: 'issn',
        target: 'ISSN'
    },
    {
        source: 'issue',
        target: 'issue',
        when: {
            source: {
                number: false,
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TYPE"]]: [
                    'article',
                    'periodical'
                ]
            },
            target: {
                issue (issue) {
                    return typeof issue === 'string' && !issue.match(/\d+/);
                },
                type: [
                    'article',
                    'article-journal',
                    'article-newspaper',
                    'article-magazine',
                    'periodical'
                ]
            }
        }
    },
    {
        source: 'number',
        target: 'issue',
        when: {
            source: {
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TYPE"]]: [
                    'article',
                    'periodical',
                    'inproceedings'
                ]
            },
            target: {
                issue (issue) {
                    return issue && (typeof issue === 'number' || issue.match(/\d+/));
                },
                type: [
                    'article',
                    'article-journal',
                    'article-newspaper',
                    'article-magazine',
                    'paper-conference',
                    'periodical'
                ]
            }
        }
    },
    {
        source: 'date',
        target: 'issued',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].DATE
    },
    {
        source: [
            'year',
            'month',
            'day'
        ],
        target: 'issued',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].YEAR_MONTH,
        when: {
            source: {
                date: false
            },
            target: false
        }
    },
    {
        source: 'location',
        target: 'jurisdiction',
        when: {
            source: {
                type: 'patent'
            },
            target: {
                type: 'patent'
            }
        }
    },
    {
        source: 'keywords',
        target: 'keyword',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].KEYWORDS
    },
    {
        source: 'language',
        target: 'language',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].PICK
    },
    {
        source: 'langid',
        target: 'language',
        when: {
            source: {
                language: false
            },
            target: false
        }
    },
    {
        source: 'note',
        target: 'note'
    },
    {
        source: 'addendum',
        target: 'note',
        when: {
            source: {
                note: false
            },
            target: false
        }
    },
    {
        source: 'eid',
        target: 'number',
        when: {
            target: {
                type: [
                    'article-journal'
                ]
            }
        }
    },
    {
        source: [
            'isan',
            'ismn',
            'isrn',
            'iswc'
        ],
        target: 'number',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].STANDARD_NUMBERS,
        when: {
            source: {
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TYPE"]] (type) {
                    return type !== 'patent';
                }
            },
            target: {
                type (type) {
                    return type !== 'patent';
                }
            }
        }
    },
    {
        source: 'number',
        target: 'number',
        when: {
            source: {
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TYPE"]]: [
                    'patent',
                    'report',
                    'techreport',
                    'legislation'
                ]
            },
            target: {
                type: [
                    'patent',
                    'report',
                    'legislation'
                ]
            }
        }
    },
    {
        source: 'origdate',
        target: 'original-date',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].DATE
    },
    {
        source: 'origlocation',
        target: 'original-publisher-place',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].PICK
    },
    {
        source: 'origpublisher',
        target: 'original-publisher',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].PICK
    },
    {
        source: 'origtitle',
        target: 'original-title'
    },
    {
        source: 'pages',
        target: 'page',
        when: {
            source: {
                bookpagination: [
                    undefined,
                    'page'
                ]
            }
        },
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].PAGES
    },
    {
        source: 'pagetotal',
        target: 'number-of-pages'
    },
    {
        source: 'part',
        target: 'part-number'
    },
    {
        source: [
            'eprint',
            'eprinttype'
        ],
        target: 'PMID',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].EPRINT
    },
    {
        source: 'location',
        target: 'publisher-place',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].PICK
    },
    {
        source: 'publisher',
        target: 'publisher',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].PICK,
        when: {
            source: true,
            target: {
                type: [
                    'article',
                    'article-journal',
                    'article-magazine',
                    'article-newspaper',
                    'bill',
                    'book',
                    'broadcast',
                    'chapter',
                    'classic',
                    'collection',
                    'dataset',
                    'document',
                    'entry',
                    'entry-dictionary',
                    'entry-encyclopedia',
                    'event',
                    'figure',
                    'graphic',
                    'hearing',
                    'interview',
                    'legal_case',
                    'legislation',
                    'manuscript',
                    'map',
                    'motion_picture',
                    'musical_score',
                    'pamphlet',
                    'patent',
                    'performance',
                    'periodical',
                    'personal_communication',
                    'post',
                    'post-weblog',
                    'regulation',
                    'review',
                    'review-book',
                    'software',
                    'song',
                    'speech',
                    'standard',
                    'treaty'
                ]
            }
        }
    },
    {
        source: 'organization',
        target: 'publisher',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].PICK,
        when: {
            source: {
                publisher: false
            },
            target: {
                type: [
                    'paper-conference',
                    'webpage'
                ]
            }
        }
    },
    {
        source: 'institution',
        target: 'publisher',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].PICK,
        when: {
            source: {
                publisher: false,
                organization: false
            },
            target: {
                type: [
                    'report',
                    'thesis'
                ]
            }
        }
    },
    {
        source: 'howpublished',
        target: 'publisher',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].PICK,
        when: {
            source: {
                howpublished (howPublished) {
                    return howPublished && !howPublished.startsWith('http');
                },
                publisher: false,
                organization: false,
                institution: false
            },
            target: {
                type: 'manuscript'
            }
        }
    },
    {
        source: [
            'pages',
            'bookpagination'
        ],
        target: 'section',
        when: {
            source: {
                bookpagination: 'section'
            },
            target: {
                page: false
            }
        },
        convert: {
            toTarget (section) {
                return section;
            },
            toSource (section) {
                return [
                    section,
                    'section'
                ];
            }
        }
    },
    {
        source: 'pubstate',
        target: 'status',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].STATUS
    },
    {
        source: 'shorttitle',
        target: 'title-short'
    },
    {
        source: 'shorttitle',
        target: 'shortTitle',
        when: {
            source: false,
            target: {
                'title-short': false
            }
        }
    },
    {
        source: [
            'title',
            'subtitle',
            'titleaddon'
        ],
        target: 'title',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].TITLE
    },
    {
        source: 'translator',
        target: 'translator',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].NAMES
    },
    {
        source: 'url',
        target: 'URL'
    },
    {
        source: 'howpublished',
        target: 'URL',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].HOW_PUBLISHED,
        when: {
            source: {
                url: false
            },
            target: false
        }
    },
    {
        source: 'version',
        target: 'version'
    },
    {
        source: 'volume',
        target: 'volume'
    },
    {
        source: 'volumes',
        target: 'number-of-volumes'
    },
    {
        source: [
            'issuetitle',
            'issuesubtitle',
            'issuetitleaddon'
        ],
        target: 'volume-title',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].TITLE
    }
]);
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/mapping/bibtex.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$core$2f$lib$2d$mjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/core/lib-mjs/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$core$2f$lib$2d$mjs$2f$util$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/core/lib-mjs/util/index.js [app-ssr] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$date$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/date/lib/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$bibtexTypes$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/mapping/bibtexTypes.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/mapping/shared.js [app-ssr] (ecmascript)");
;
;
;
;
const __TURBOPACK__default__export__ = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$core$2f$lib$2d$mjs$2f$util$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].Translator([
    {
        source: 'note',
        target: 'accessed',
        when: {
            source: false,
            target: {
                note: false
            }
        },
        convert: {
            toSource (accessed) {
                return `[Online; accessed ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$date$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(accessed)}]`;
            }
        }
    },
    {
        source: 'annote',
        target: 'annote'
    },
    {
        source: 'address',
        target: 'publisher-place',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].PICK
    },
    {
        source: 'author',
        target: 'author',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].NAMES
    },
    {
        source: 'chapter',
        target: 'chapter-number'
    },
    {
        source: 'number',
        target: 'collection-number',
        when: {
            source: {
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TYPE"]]: [
                    'book',
                    'mvbook',
                    'inbook',
                    'collection',
                    'mvcollection',
                    'incollection',
                    'suppcollection',
                    'manual',
                    'suppperiodical',
                    'proceedings',
                    'mvproceedings',
                    'refererence'
                ]
            },
            target: {
                type: [
                    'bill',
                    'book',
                    'broadcast',
                    'chapter',
                    'dataset',
                    'entry',
                    'entry-dictionary',
                    'entry-encyclopedia',
                    'figure',
                    'graphic',
                    'interview',
                    'legislation',
                    'legal_case',
                    'manuscript',
                    'map',
                    'motion_picture',
                    'musical_score',
                    'pamphlet',
                    'post',
                    'post-weblog',
                    'personal_communication',
                    'review',
                    'review-book',
                    'song',
                    'speech',
                    'thesis',
                    'treaty',
                    'webpage'
                ]
            }
        }
    },
    {
        source: 'series',
        target: 'collection-title'
    },
    {
        source: 'booktitle',
        target: 'container-title',
        when: {
            target: {
                type: [
                    'chapter',
                    'paper-conference'
                ]
            }
        }
    },
    {
        source: 'journal',
        target: 'container-title',
        when: {
            source: {
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TYPE"]]: 'article'
            },
            target: {
                type: [
                    'article',
                    'article-newspaper',
                    'article-journal',
                    'article-magazine'
                ]
            }
        }
    },
    {
        source: 'doi',
        target: 'DOI'
    },
    {
        source: 'edition',
        target: 'edition'
    },
    {
        source: 'editor',
        target: 'editor',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].NAMES
    },
    {
        source: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LABEL"],
        target: [
            'id',
            'citation-key',
            'author',
            'issued',
            'year-suffix',
            'title'
        ],
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].LABEL
    },
    {
        source: 'isbn',
        target: 'ISBN'
    },
    {
        source: 'issn',
        target: 'ISSN'
    },
    {
        source: 'number',
        target: 'issue',
        when: {
            source: {
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TYPE"]]: [
                    'article',
                    'periodical',
                    'inproceedings'
                ]
            },
            target: {
                issue (issue) {
                    return typeof issue === 'number' || typeof issue === 'string' && issue.match(/\d+/);
                },
                type: [
                    'article',
                    'article-journal',
                    'article-newspaper',
                    'article-magazine',
                    'paper-conference',
                    'periodical'
                ]
            }
        }
    },
    {
        source: [
            'year',
            'month',
            'day'
        ],
        target: 'issued',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].YEAR_MONTH
    },
    {
        source: 'note',
        target: 'note'
    },
    {
        source: 'number',
        target: 'number',
        when: {
            source: {
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TYPE"]]: [
                    'patent',
                    'report',
                    'techreport'
                ]
            },
            target: {
                type: [
                    'patent',
                    'report'
                ]
            }
        }
    },
    {
        source: 'eid',
        target: 'number',
        when: {
            source: {
                number: false
            },
            target: {
                type: [
                    'article-journal'
                ]
            }
        }
    },
    {
        source: 'pages',
        target: 'page',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].PAGES
    },
    {
        source: 'publisher',
        target: 'publisher',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].PICK,
        when: {
            target: {
                type: [
                    'article',
                    'article-journal',
                    'article-magazine',
                    'article-newspaper',
                    'bill',
                    'book',
                    'broadcast',
                    'chapter',
                    'classic',
                    'collection',
                    'dataset',
                    'document',
                    'entry',
                    'entry-dictionary',
                    'entry-encyclopedia',
                    'event',
                    'figure',
                    'graphic',
                    'hearing',
                    'interview',
                    'legal_case',
                    'legislation',
                    'map',
                    'motion_picture',
                    'musical_score',
                    'pamphlet',
                    'patent',
                    'performance',
                    'periodical',
                    'personal_communication',
                    'post',
                    'post-weblog',
                    'regulation',
                    'review',
                    'review-book',
                    'software',
                    'song',
                    'speech',
                    'standard',
                    'treaty',
                    'webpage'
                ]
            }
        }
    },
    {
        source: 'organization',
        target: 'publisher',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].PICK,
        when: {
            source: {
                publisher: false
            },
            target: {
                type: 'paper-conference'
            }
        }
    },
    {
        source: 'institution',
        target: 'publisher',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].PICK,
        when: {
            source: {
                publisher: false,
                organization: false
            },
            target: {
                type: 'report'
            }
        }
    },
    {
        source: 'school',
        target: 'publisher',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].PICK,
        when: {
            source: {
                institution: false,
                organization: false,
                publisher: false
            },
            target: {
                type: 'thesis'
            }
        }
    },
    {
        source: 'howpublished',
        target: 'publisher',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].PICK,
        when: {
            source: {
                howpublished (howPublished) {
                    return howPublished && !howPublished.startsWith('http');
                },
                publisher: false,
                organization: false,
                institution: false,
                school: false
            },
            target: {
                type: 'manuscript'
            }
        }
    },
    {
        source: 'title',
        target: 'title'
    },
    {
        source: [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TYPE"],
            'type'
        ],
        target: [
            'type',
            'genre'
        ],
        convert: {
            toTarget (sourceType, subType) {
                const type = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$bibtexTypes$2e$json__$28$json$29$__["default"].source[sourceType] || 'document';
                if (subType) {
                    return [
                        type,
                        subType
                    ];
                } else if (sourceType === 'mastersthesis') {
                    return [
                        type,
                        'Master\'s thesis'
                    ];
                } else if (sourceType === 'phdthesis') {
                    return [
                        type,
                        'PhD thesis'
                    ];
                } else {
                    return [
                        type
                    ];
                }
            },
            toSource (targetType, genre) {
                const type = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$bibtexTypes$2e$json__$28$json$29$__["default"].target[targetType] || 'misc';
                if (/^(master'?s|diploma) thesis$/i.test(genre)) {
                    return [
                        'mastersthesis'
                    ];
                } else if (/^(phd|doctoral) thesis$/i.test(genre)) {
                    return [
                        'phdthesis'
                    ];
                } else {
                    return [
                        type,
                        genre
                    ];
                }
            }
        }
    },
    {
        source: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TYPE"],
        when: {
            target: {
                type: false
            }
        },
        convert: {
            toSource () {
                return 'misc';
            }
        }
    },
    {
        source: 'url',
        target: 'URL'
    },
    {
        source: 'howpublished',
        target: 'URL',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Converters"].HOW_PUBLISHED,
        when: {
            target: {
                publisher: false
            }
        }
    },
    {
        source: 'volume',
        target: 'volume'
    }
]);
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/mapping/crossref.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "crossref",
    ()=>crossref
]);
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
const BOOK = new Set([
    'book',
    'inbook',
    'bookinbook',
    'suppbook'
]);
const BOOK_PART = new Set([
    'inbook',
    'bookinbook',
    'suppbook'
]);
const COLLECTION = new Set([
    'collection',
    'reference',
    'incollection',
    'inreference',
    'suppcollection'
]);
const COLLECTION_PART = new Set([
    'incollection',
    'inreference',
    'suppcollection'
]);
const PROCEEDINGS = new Set([
    'proceedings',
    'inproceedings'
]);
const PROCEEDINGS_PART = new Set([
    'inproceedings'
]);
const PERIODICAL_PART = new Set([
    'article',
    'suppperiodical'
]);
const TITLE_MAP = {
    mvbook: [
        'main',
        BOOK
    ],
    mvcollection: [
        'main',
        COLLECTION
    ],
    mvreference: [
        'main',
        COLLECTION
    ],
    mvproceedings: [
        'main',
        PROCEEDINGS
    ],
    book: [
        'book',
        BOOK_PART
    ],
    collection: [
        'book',
        COLLECTION_PART
    ],
    reference: [
        'book',
        COLLECTION_PART
    ],
    proceedings: [
        'book',
        PROCEEDINGS_PART
    ],
    periodical: [
        'journal',
        PERIODICAL_PART
    ]
};
function crossref(target, entry, registry) {
    if (entry.crossref in registry) {
        const parent = registry[entry.crossref];
        if (parent.properties === entry) {
            return entry;
        }
        const data = _objectSpread({}, crossref(parent.type, parent.properties, registry));
        delete data.ids;
        delete data.crossref;
        delete data.xref;
        delete data.entryset;
        delete data.entrysubtype;
        delete data.execute;
        delete data.label;
        delete data.options;
        delete data.presort;
        delete data.related;
        delete data.relatedoptions;
        delete data.relatedstring;
        delete data.relatedtype;
        delete data.shortand;
        delete data.shortandintro;
        delete data.sortkey;
        if ((parent.type === 'mvbook' || parent.type === 'book') && BOOK_PART.has(target)) {
            data.bookauthor = data.author;
        }
        if (parent.type in TITLE_MAP) {
            const [prefix, targets] = TITLE_MAP[parent.type];
            if (targets.has(target)) {
                data[prefix + 'title'] = data.title;
                data[prefix + 'subtitle'] = data.subtitle;
                if (prefix !== 'journal') {
                    data[prefix + 'titleaddon'] = data.titleaddon;
                }
                delete data.title;
                delete data.subtitle;
                delete data.titleaddon;
                delete data.shorttitle;
                delete data.sorttitle;
                delete data.indextitle;
                delete data.indexsorttitle;
            }
        }
        return Object.assign(data, entry);
    }
    return entry;
}
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/mapping/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "format",
    ()=>format,
    "formatBibtex",
    ()=>formatBibtex,
    "parse",
    ()=>parse,
    "parseBibtex",
    ()=>parseBibtex
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/mapping/shared.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$biblatex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/mapping/biblatex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$bibtex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/mapping/bibtex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$crossref$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/mapping/crossref.js [app-ssr] (ecmascript)");
function _objectWithoutProperties(e, t) {
    if (null == e) return {};
    var o, r, i = _objectWithoutPropertiesLoose(e, t);
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(e);
        for(r = 0; r < s.length; r++)o = s[r], t.includes(o) || ({}).propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
}
function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for(var n in r)if (({}).hasOwnProperty.call(r, n)) {
        if (e.includes(n)) continue;
        t[n] = r[n];
    }
    return t;
}
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
;
;
;
;
function _parse(input, spec) {
    const registry = {};
    for (const entry of input){
        registry[entry.label] = entry;
    }
    return input.map(({ type, label, properties })=>spec.convertToTarget(_objectSpread({
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TYPE"]]: type,
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LABEL"]]: label
        }, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$crossref$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["crossref"])(type, properties, registry))));
}
function _format(input, spec) {
    return input.map((entry)=>{
        const _spec$convertToSource = spec.convertToSource(entry), { [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TYPE"]]: type, [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LABEL"]]: label } = _spec$convertToSource, properties = _objectWithoutProperties(_spec$convertToSource, [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TYPE"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LABEL"]
        ].map(_toPropertyKey));
        return {
            type,
            label,
            properties
        };
    });
}
function parseBibtex(input) {
    return _parse(input, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$bibtex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
}
function formatBibtex(input) {
    return _format(input, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$bibtex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
}
function parse(input) {
    return _parse(input, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$biblatex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
}
function format(input) {
    return _format(input, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$biblatex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
}
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/input/name.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "formatNameParts",
    ()=>formatNameParts,
    "getStringCase",
    ()=>getStringCase,
    "orderNameParts",
    ()=>orderNameParts,
    "orderNamePieces",
    ()=>orderNamePieces
]);
function getStringCase(string) {
    const a = string.toUpperCase();
    const b = string.toLowerCase();
    for(let i = 0; i < string.length; i++){
        if (a[i] !== b[i]) {
            return a[i] === string[i];
        }
    }
    return null;
}
function formatNameParts(parts) {
    if (parts.length === 0) {
        return undefined;
    }
    let piece = '';
    while(parts.length > 1){
        const { value, hyphenated } = parts.shift();
        piece += value + (hyphenated ? '-' : ' ');
    }
    const output = piece + parts[0].value;
    return output[0] && output;
}
function orderNameParts(parts, orderGiven = true) {
    const given = [];
    const undecided = [];
    if (orderGiven) {
        while(parts.length > 1 && parts[0].upperCase !== false){
            given.push(...undecided);
            undecided.length = 0;
            while(parts.length > 1 && parts[0].upperCase !== false && !parts[0].hyphenated){
                given.push(parts.shift());
            }
            while(parts.length > 0 && parts[0].upperCase !== false && parts[0].hyphenated){
                undecided.push(parts.shift());
            }
        }
    }
    const prefix = [];
    const family = [];
    while(parts.length > 1){
        prefix.push(...family);
        family.length = 0;
        while(parts.length > 1 && parts[0].upperCase === false){
            prefix.push(parts.shift());
        }
        while(parts.length > 0 && parts[0].upperCase !== false){
            family.push(parts.shift());
        }
    }
    if (undecided.length) {
        family.unshift(...undecided);
    }
    if (parts.length) {
        family.push(parts[0]);
    }
    return [
        formatNameParts(given),
        formatNameParts(prefix),
        formatNameParts(family)
    ];
}
function orderNamePieces(pieces) {
    if (pieces[0][0].label) {
        const name = {};
        for (const [{ value, label }] of pieces){
            name[label] = value;
        }
        return name;
    }
    const name = {};
    const [given, prefix, family] = orderNameParts(pieces[0], pieces.length === 1);
    if (family) {
        name.family = family;
    }
    if (prefix) {
        name.prefix = prefix;
    }
    if (pieces.length === 3) {
        name.given = formatNameParts(pieces[2]);
        name.suffix = formatNameParts(pieces[1]);
    } else if (pieces.length === 2) {
        name.given = formatNameParts(pieces[1]);
    } else if (given) {
        name.given = given;
    }
    return name;
}
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/input/value.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "parse",
    ()=>parse,
    "parseAnnotation",
    ()=>parseAnnotation,
    "valueGrammar",
    ()=>valueGrammar
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$core$2f$lib$2d$mjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/core/lib-mjs/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$core$2f$lib$2d$mjs$2f$util$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/core/lib-mjs/util/index.js [app-ssr] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$moo$2f$moo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/moo/moo.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/config.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/input/constants.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$name$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/input/name.js [app-ssr] (ecmascript)");
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
;
;
;
;
;
const text = {
    commandBegin: {
        match: '\\begin',
        push: 'environment'
    },
    command: {
        match: /\\(?:[a-zA-Z]+|.) */,
        value: (s)=>s.slice(1).trim()
    },
    lbrace: {
        match: '{',
        push: 'bracedLiteral'
    },
    mathShift: {
        match: '$',
        push: 'mathLiteral'
    },
    whitespace: {
        match: /[\s]+|~/,
        lineBreaks: true,
        value (token) {
            return token === '~' ? '\xa0' : ' ';
        }
    }
};
const lexer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$moo$2f$moo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].states({
    stringLiteral: _objectSpread(_objectSpread({}, text), {}, {
        text: /[^{$}\s~\\]+/
    }),
    namesLiteral: _objectSpread(_objectSpread({
        and: /\s+[aA][nN][dD]\s+/,
        comma: ',',
        hyphen: '-',
        equals: '='
    }, text), {}, {
        text: /[^{$}\s~\\,=-]+/
    }),
    listLiteral: _objectSpread(_objectSpread({
        and: /\s+and\s+/
    }, text), {}, {
        text: /[^{$}\s~\\]+/
    }),
    separatedLiteral: _objectSpread(_objectSpread({
        comma: ','
    }, text), {}, {
        text: /[^{$}\s~\\,]+/
    }),
    annotation: _objectSpread(_objectSpread({}, text), {}, {
        colon: ':',
        equals: '=',
        comma: ',',
        semicolon: ';',
        quote: '"',
        itemCount: /\d+/,
        text: /[^{$}\s~\\":;,=]+/
    }),
    bracedLiteral: _objectSpread(_objectSpread({}, text), {}, {
        rbrace: {
            match: '}',
            pop: true
        },
        text: /[^{$}\s~\\]+/
    }),
    mathLiteral: _objectSpread(_objectSpread({}, text), {}, {
        mathShift: {
            match: '$',
            pop: true
        },
        script: /[\^_]/,
        text: /[^{$}\s~\\^_]+/
    }),
    environment: _objectSpread(_objectSpread({
        commandEnd: {
            match: '\\end',
            pop: true
        }
    }, text), {}, {
        text: /[^{$}\s~\\]+/
    })
});
function flattenConsString(string) {
    string[0];
    return string;
}
function applyFormatting(text, format) {
    if (format in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["formatting"]) {
        return text && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["formatting"][format].join(text);
    } else {
        return text;
    }
}
const valueGrammar = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$core$2f$lib$2d$mjs$2f$util$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].Grammar({
    String () {
        let output = '';
        while(!this.matchEndOfFile()){
            output += this.consumeRule('Text');
        }
        return flattenConsString(output);
    },
    StringNames () {
        const list = [];
        while(true){
            this.consumeToken('whitespace', true);
            list.push(this.consumeRule('Name'));
            this.consumeToken('whitespace', true);
            if (this.matchEndOfFile()) {
                return list;
            } else {
                this.consumeToken('and');
            }
        }
    },
    Name () {
        const pieces = [];
        while(true){
            pieces.push(this.consumeRule('NamePiece'));
            if (this.matchEndOfFile() || this.matchToken('and')) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$name$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["orderNamePieces"])(pieces);
            } else {
                this.consumeToken('comma');
                this.consumeToken('whitespace', true);
            }
        }
    },
    NamePiece () {
        const parts = [];
        while(true){
            const part = this.consumeRule('NameToken');
            if (part.label) {
                part.label = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$name$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["formatNameParts"])([
                    ...parts,
                    {
                        value: part.label
                    }
                ]);
                return [
                    part
                ];
            }
            parts.push(part);
            if (this.matchEndOfFile() || this.matchToken('and') || this.matchToken('comma')) {
                return parts;
            } else {
                while(this.matchToken('hyphen') || this.matchToken('whitespace')){
                    this.consumeToken();
                }
            }
        }
    },
    NameToken () {
        let upperCase = null;
        let value = '';
        while(true){
            if (upperCase === null && this.matchToken('text')) {
                const text = this.consumeToken().value;
                value += text;
                upperCase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$name$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getStringCase"])(text);
            } else if (this.matchEndOfFile() || this.matchToken('and') || this.matchToken('comma') || this.matchToken('whitespace')) {
                return {
                    value,
                    upperCase
                };
            } else if (this.matchToken('hyphen')) {
                return {
                    value,
                    upperCase,
                    hyphenated: true
                };
            } else if (this.matchToken('equals')) {
                this.consumeToken('equals');
                const text = this.consumeRule('NamePiece');
                if (text[0].label) {
                    value += '=' + text[0].label;
                }
                return {
                    value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$name$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["formatNameParts"])(text),
                    label: value
                };
            } else {
                value += this.consumeRule('Text');
            }
        }
    },
    StringList () {
        const list = [];
        while(!this.matchEndOfFile()){
            let output = '';
            while(!this.matchEndOfFile() && !this.matchToken('and')){
                output += this.consumeRule('Text');
            }
            list.push(flattenConsString(output));
            this.consumeToken('and', true);
        }
        return list.length === 1 ? list[0] : list;
    },
    StringSeparated () {
        const list = [];
        while(!this.matchEndOfFile()){
            let output = '';
            while(!this.matchEndOfFile() && !this.matchToken('comma')){
                output += this.consumeRule('Text');
            }
            list.push(output.trim());
            this.consumeToken('comma', true);
            this.consumeToken('whitespace', true);
        }
        return list;
    },
    StringVerbatim () {
        let output = '';
        while(!this.matchEndOfFile()){
            output += this.consumeToken().text;
        }
        return flattenConsString(output);
    },
    StringUri () {
        const uri = this.consumeRule('StringVerbatim');
        try {
            if (decodeURI(uri) === uri) {
                return encodeURI(uri);
            } else {
                return uri;
            }
        } catch (e) {
            return encodeURI(uri);
        }
    },
    StringTitleCase () {
        this.state.sentenceCase = true;
        let output = '';
        while(!this.matchEndOfFile()){
            output += this.consumeRule('Text');
        }
        return flattenConsString(output);
    },
    Annotations () {
        const annotations = {};
        while(true){
            const { scope, item, part, value } = this.consumeRule('Annotation');
            if (scope === 'part') {
                if (!annotations.part) {
                    annotations.part = [];
                }
                if (!annotations.part[item]) {
                    annotations.part[item] = {};
                }
                annotations.part[item][part] = value;
            } else if (scope === 'item') {
                if (!annotations.item) {
                    annotations.item = [];
                }
                annotations.item[item] = value;
            } else {
                annotations.field = value;
            }
            if (this.matchEndOfFile()) {
                break;
            } else {
                this.consumeToken('semicolon');
                this.consumeRule('_');
            }
        }
        return annotations;
    },
    Annotation () {
        const annotation = {};
        if (this.matchToken('itemCount')) {
            annotation.item = parseInt(this.consumeToken('itemCount')) - 1;
            if (this.matchToken('colon')) {
                this.consumeToken('colon');
                annotation.part = this.consumeToken('text');
                annotation.scope = 'part';
            } else {
                annotation.scope = 'item';
            }
        } else {
            annotation.scope = 'field';
        }
        this.consumeToken('equals');
        this.consumeRule('_');
        if (this.matchToken('quote')) {
            this.consumeToken('quote');
            let literal = '';
            while(!this.matchToken('quote')){
                if (this.matchToken('itemCount') || this.matchToken('colon') || this.matchToken('comma') || this.matchToken('semicolon') || this.matchToken('equals')) {
                    literal += this.token.value;
                    this.token = this.lexer.next();
                } else {
                    literal += this.consumeRule('Text');
                }
            }
            this.consumeToken('quote');
            annotation.value = flattenConsString(literal);
            this.consumeRule('_');
        } else {
            annotation.value = [];
            let output = '';
            while(true){
                output += this.consumeRule('Text');
                if (this.matchToken('comma')) {
                    this.consumeToken('comma');
                    this.consumeRule('_');
                    annotation.value.push(flattenConsString(output));
                    output = '';
                } else if (this.matchEndOfFile() || this.matchToken('semicolon')) {
                    annotation.value.push(flattenConsString(output));
                    break;
                }
            }
        }
        return annotation;
    },
    BracketString () {
        var _this$state;
        let output = '';
        this.consumeToken('lbrace');
        const sentenceCase = this.state.sentenceCase;
        this.state.sentenceCase = sentenceCase && this.matchToken('command');
        (_this$state = this.state).partlyLowercase && (_this$state.partlyLowercase = this.state.sentenceCase);
        while(!this.matchToken('rbrace')){
            output += this.consumeRule('Text');
        }
        const topLevel = sentenceCase && !this.state.sentenceCase;
        const protectCase = topLevel && this.state.partlyLowercase;
        this.state.sentenceCase = sentenceCase;
        this.consumeToken('rbrace');
        return protectCase ? applyFormatting(output, 'nocase') : output;
    },
    MathString () {
        let output = '';
        this.consumeToken('mathShift');
        while(!this.matchToken('mathShift')){
            if (this.matchToken('script')) {
                const script = this.consumeToken('script').value;
                const text = this.consumeRule('Text').split('');
                if (text.every((char)=>char in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mathScripts"][script])) {
                    output += text.map((char)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mathScripts"][script][char]).join('');
                } else {
                    const formatName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mathScriptFormatting"][script];
                    output += __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["formatting"][formatName].join(text.join(''));
                }
                continue;
            }
            if (this.matchToken('command')) {
                const command = this.token.value;
                if (command in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mathScriptFormatting"]) {
                    this.consumeToken('command');
                    const text = this.consumeRule('BracketString');
                    output += applyFormatting(text, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mathScriptFormatting"][command]);
                    continue;
                }
            }
            output += this.consumeRule('Text');
        }
        this.consumeToken('mathShift');
        return output;
    },
    Text () {
        if (this.matchToken('lbrace')) {
            return this.consumeRule('BracketString');
        } else if (this.matchToken('mathShift')) {
            return this.consumeRule('MathString');
        } else if (this.matchToken('whitespace')) {
            return this.consumeToken('whitespace').value;
        } else if (this.matchToken('commandBegin')) {
            return this.consumeRule('EnclosedEnv');
        } else if (this.matchToken('command')) {
            return this.consumeRule('Command');
        }
        const text = this.consumeToken('text').value.replace(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ligaturePattern"], (ligature)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ligatures"][ligature]);
        const afterPunctuation = this.state.afterPunctuation;
        this.state.afterPunctuation = /[?!.:]$/.test(text);
        if (!this.state.sentenceCase) {
            var _this$state2;
            (_this$state2 = this.state).partlyLowercase || (_this$state2.partlyLowercase = text === text.toLowerCase() && text !== text.toUpperCase());
            return text;
        }
        const [first, ...otherCharacters] = text;
        const rest = otherCharacters.join('');
        const restLowerCase = rest.toLowerCase();
        if (rest !== restLowerCase) {
            return text;
        }
        if (!afterPunctuation) {
            return text.toLowerCase();
        }
        return first + restLowerCase;
    },
    Command () {
        const commandToken = this.consumeToken('command');
        const command = commandToken.value;
        if (command in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["formattingEnvs"]) {
            const text = this.consumeRule('Env');
            const format = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["formattingEnvs"][command];
            return applyFormatting(text, format);
        } else if (command in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["formattingCommands"]) {
            const text = this.consumeRule('BracketString');
            const format = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["formattingCommands"][command];
            return applyFormatting(text, format);
        } else if (command in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["commands"]) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["commands"][command];
        } else if (command in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mathCommands"]) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mathCommands"][command];
        } else if (command in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["diacritics"] && !this.matchEndOfFile()) {
            const text = this.consumeRule('Text');
            const diacritic = text[0] + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["diacritics"][command];
            return diacritic.normalize('NFC') + text.slice(1);
        } else if (command in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["argumentCommands"]) {
            const func = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["argumentCommands"][command];
            const args = [];
            let arity = func.length;
            while(arity-- > 0){
                this.consumeToken('whitespace', true);
                args.push(this.consumeRule('BracketString'));
            }
            return func(...args);
        } else if (/^[&%$#_{}]$/.test(command)) {
            return commandToken.text.slice(1);
        } else {
            return commandToken.text;
        }
    },
    Env () {
        let output = '';
        while(!this.matchEndOfFile() && !this.matchToken('rbrace')){
            output += this.consumeRule('Text');
        }
        return output;
    },
    EnclosedEnv () {
        this.consumeToken('commandBegin');
        const beginEnv = this.consumeRule('BracketString');
        let output = '';
        while(!this.matchToken('commandEnd')){
            output += this.consumeRule('Text');
        }
        const end = this.consumeToken('commandEnd');
        const endEnv = this.consumeRule('BracketString');
        if (beginEnv !== endEnv) {
            throw new SyntaxError(this.lexer.formatError(end, `environment started with "${beginEnv}", ended with "${endEnv}"`));
        }
        return applyFormatting(output, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["formattingEnvs"][beginEnv]);
    },
    _ () {
        while(this.matchToken('whitespace')){
            this.consumeToken('whitespace');
        }
    }
}, {
    sentenceCase: false,
    partlyLowercase: false,
    afterPunctuation: true
});
function singleLanguageIsEnglish(language) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sentenceCaseLanguages"].includes(language.toLowerCase());
}
function isEnglish(languages) {
    if (Array.isArray(languages)) {
        return languages.every(singleLanguageIsEnglish);
    }
    return singleLanguageIsEnglish(languages);
}
function getMainRule(fieldType, languages) {
    if (fieldType[1] === 'name') {
        return fieldType[0] === 'list' ? 'StringNames' : 'Name';
    }
    if (fieldType[1] === 'title') {
        const option = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].parse.sentenceCase;
        if (option === 'always' || option === 'english' && isEnglish(languages)) {
            return 'StringTitleCase';
        } else {
            return 'String';
        }
    }
    switch(fieldType[0] === 'field' ? fieldType[1] : fieldType[0]){
        case 'list':
            return 'StringList';
        case 'separated':
            return 'StringSeparated';
        case 'verbatim':
            return 'StringVerbatim';
        case 'uri':
            return 'StringUri';
        case 'title':
        case 'literal':
        default:
            return 'String';
    }
}
function getLexerState(fieldType) {
    if (fieldType[1] === 'name') {
        return 'namesLiteral';
    }
    switch(fieldType[0]){
        case 'list':
            return 'listLiteral';
        case 'separated':
            return 'separatedLiteral';
        case 'field':
        default:
            return 'stringLiteral';
    }
}
function parse(text, field, languages = []) {
    const fieldType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fieldTypes"][field] || [];
    return valueGrammar.parse(lexer.reset(text, {
        state: getLexerState(fieldType),
        line: 0,
        col: 0
    }), getMainRule(fieldType, languages));
}
function parseAnnotation(text) {
    return valueGrammar.parse(lexer.reset(text, {
        state: 'annotation',
        line: 0,
        col: 0
    }), 'Annotations');
}
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/input/entries.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "parse",
    ()=>parse,
    "parseBibtex",
    ()=>parseBibtex
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/config.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/mapping/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$value$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/input/value.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/input/constants.js [app-ssr] (ecmascript)");
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
;
;
;
;
function validate(entries, requirements) {
    const problems = [];
    for (const { type, label, properties } of entries){
        if (type in requirements) {
            const missing = [];
            for (const field of requirements[type]){
                if (Array.isArray(field) && !field.some((field)=>field in properties)) {
                    missing.push(field.join('/'));
                } else if (typeof field === 'string' && !(field in properties)) {
                    missing.push(field);
                }
            }
            if (missing.length) {
                problems.push([
                    label,
                    `missing fields: ${missing.join(', ')}`
                ]);
            }
        } else {
            problems.push([
                label,
                `invalid type: "${type}"`
            ]);
        }
    }
    if (problems.length) {
        throw new RangeError([
            'Invalid entries:'
        ].concat(problems.map(([label, problem])=>`  - ${label} has ${problem}`)).join('\n'));
    }
}
function parseEntryValues(entry) {
    const output = {};
    if ('language' in entry.properties) {
        output.language = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$value$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(entry.properties.language, 'language');
    }
    for(const property in entry.properties){
        const value = entry.properties[property];
        if (value === '') {
            continue;
        }
        output[property] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$value$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(value + '', property, output.language);
    }
    for(const property in entry.annotations){
        for(const annotation in entry.annotations[property]){
            output[property + '+an:' + annotation] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$value$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseAnnotation"])(entry.annotations[property][annotation]);
        }
    }
    return _objectSpread(_objectSpread({}, entry), {}, {
        properties: output
    });
}
function parse(entries) {
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].parse.strict) {
        validate(entries, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["required"].biblatex);
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(entries.map(parseEntryValues));
}
function parseBibtex(entries) {
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].parse.strict) {
        validate(entries, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["required"].bibtex);
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseBibtex"])(entries.map(parseEntryValues));
}
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/input/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "formats",
    ()=>formats,
    "ref",
    ()=>ref
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$file$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/input/file.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$bibtxt$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/input/bibtxt.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$entries$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/input/entries.js [app-ssr] (ecmascript)");
;
;
;
const ref = '@bibtex';
const formats = {
    '@biblatex/text': {
        parse: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$file$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"],
        parseType: {
            dataType: 'String',
            predicate: /@\s{0,5}[A-Za-z]{1,13}\s{0,5}\{\s{0,5}[^@{}"=,\\\s]{0,100}\s{0,5},[\s\S]*\}/
        }
    },
    '@biblatex/entry+object': {
        parse (input) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$entries$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])([
                input
            ]);
        },
        parseType: {
            dataType: 'SimpleObject',
            propertyConstraint: {
                props: [
                    'type',
                    'label',
                    'properties'
                ]
            }
        }
    },
    '@biblatex/entries+list': {
        parse: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$entries$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"],
        parseType: {
            elementConstraint: '@biblatex/entry+object'
        }
    },
    '@bibtex/text': {
        parse: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$file$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"],
        outputs: '@bibtex/entries+list'
    },
    '@bibtex/entry+object': {
        parse (input) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$entries$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseBibtex"])([
                input
            ]);
        }
    },
    '@bibtex/entries+list': {
        parse: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$entries$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseBibtex"]
    },
    '@bibtxt/text': {
        parse: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$bibtxt$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"],
        parseType: {
            dataType: 'String',
            predicate: /^\s*(\[(?!\s*[{[]).*?\]\s*(\n\s*[^[]((?!:)\S)+\s*:\s*.+?\s*)*\s*)+$/
        }
    }
};
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/output/value.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "format",
    ()=>format,
    "formatAnnotation",
    ()=>formatAnnotation
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/config.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/input/constants.js [app-ssr] (ecmascript)");
;
;
const unicode = {};
for(const command in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["commands"]){
    unicode[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["commands"][command]] = command;
}
for(const diacritic in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["diacritics"]){
    unicode[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["diacritics"][diacritic]] = diacritic;
}
for(const ligature in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ligatures"]){
    unicode[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ligatures"][ligature]] = ligature;
}
const mathUnicode = {};
for(const command in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mathCommands"]){
    mathUnicode[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mathCommands"][command]] = command;
}
const UNSAFE_UNICODE = /[^a-zA-Z0-9\s!"'()*+,\-./:;=?@[\]\u0300-\u0308\u030a-\u030c\u0332\u0323\u0327\u0328\u0361\u0326]/g;
const DIACRITIC_PATTERN = /.[\u0300-\u0308\u030a-\u030c\u0332\u0323\u0327\u0328\u0361\u0326]+/g;
const LONE_DIACRITIC_PATTERN = /[\u0300-\u0308\u030a-\u030c\u0332\u0323\u0327\u0328\u0361\u0326]/g;
const listDelimiters = {
    separated: ',',
    list: ' and '
};
const richTextMappings = {
    i: '\\textit{',
    b: '\\textbf{',
    sc: '\\textsc{',
    sup: '\\textsuperscript{',
    sub: '\\textsubscript{',
    'span style="font-variant:small-caps;"': '\\textsc{',
    'span class="nocase"': '{'
};
function escapeCharacter(char) {
    if (char in unicode) {
        return unicode[char] in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ligatures"] ? unicode[char] : `\\${unicode[char]}{}`;
    } else if (char in mathUnicode) {
        return `$\\${mathUnicode[char]}$`;
    } else if (/^[&%$#_{}]$/.test(char)) {
        return `\\${char}`;
    } else {
        return '';
    }
}
function escapeValue(value) {
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].format.asciiOnly) {
        return value;
    }
    return value.normalize('NFKD').replace(UNSAFE_UNICODE, (char)=>escapeCharacter(char)).replace(DIACRITIC_PATTERN, (match)=>Array.from(match).reduce((subject, diacritic)=>`{\\${unicode[diacritic]} ${subject}}`)).replace(LONE_DIACRITIC_PATTERN, '');
}
function formatRichText(value) {
    const closingTags = [];
    let tokens = value.split(/<(\/?(?:i|b|sc|sup|sub|span)|span .*?)>/g);
    tokens = tokens.map((token, index)=>{
        if (index % 2 === 0) {
            return escapeValue(token);
        } else if (token in richTextMappings) {
            closingTags.push('/' + token.split(' ')[0]);
            return richTextMappings[token];
        } else if (token === closingTags[closingTags.length - 1]) {
            closingTags.pop();
            return '}';
        } else {
            return '';
        }
    });
    return tokens.join('');
}
function formatName(name) {
    if (name.family && !name.prefix && !name.given & !name.suffix) {
        return name.family.includes(listDelimiters.list) ? name.family : `{${name.family}}`;
    }
    const parts = [
        ''
    ];
    if (name.prefix && name.family) {
        parts[0] += name.prefix + ' ';
    }
    if (name.family) {
        parts[0] += name.family;
    }
    if (name.suffix) {
        parts.push(name.suffix);
        parts.push(name.given || '');
    } else {
        parts.push(name.given);
    }
    return escapeValue(parts.join(', ').trim());
}
function formatTitle(title) {
    return formatRichText(title).split(/(:\s*)/).map((part, i)=>i % 2 ? part : part.replace(/([^\\])\b([a-z]*[A-Z].*?)\b/g, '$1{$2}')).join('');
}
function formatSingleValue(value, valueType) {
    switch(valueType){
        case 'title':
            return formatTitle(value);
        case 'literal':
            return formatRichText(value.toString());
        case 'name':
            return formatName(value);
        case 'verbatim':
        case 'uri':
            return value.toString();
        default:
            return escapeValue(value.toString());
    }
}
function formatList(values, valueType, listType) {
    const delimiter = listDelimiters[listType];
    return values.map((value)=>{
        const formatted = formatSingleValue(value, valueType);
        return formatted.includes(delimiter) ? `{${formatted}}` : formatted;
    }).join(delimiter);
}
function formatAnnotationValue(values) {
    if (Array.isArray(values)) {
        return values.map((value)=>escapeValue(value).replace(/([;,"])/g, '{$1}')).join(', ');
    } else {
        return '"' + escapeValue(values).replace(/(["])/g, '{$1}') + '"';
    }
}
function format(field, value) {
    if (!(field in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fieldTypes"])) {
        return formatSingleValue(value, 'verbatim');
    }
    const [listType, valueType] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fieldTypes"][field];
    if (listType in listDelimiters) {
        return formatList(value, valueType, listType);
    } else {
        return formatSingleValue(value, valueType);
    }
}
function formatAnnotation(value) {
    const annotations = [];
    if (value.field) {
        annotations.push('=' + formatAnnotationValue(value.field));
    }
    if (value.item) {
        for (const [itemCount, itemValue] of Object.entries(value.item)){
            if (!itemValue) {
                continue;
            }
            const i = parseInt(itemCount) + 1;
            annotations.push(i + '=' + formatAnnotationValue(itemValue));
        }
    }
    if (value.part) {
        for (const [itemCount, itemValue] of Object.entries(value.part)){
            if (!itemValue) {
                continue;
            }
            const i = parseInt(itemCount) + 1;
            for(const part in itemValue){
                if (!itemValue[part]) {
                    continue;
                }
                annotations.push(i + ':' + part + '=' + formatAnnotationValue(itemValue[part]));
            }
        }
    }
    return annotations.join('; ');
}
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/output/entries.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "format",
    ()=>format,
    "formatBibtex",
    ()=>formatBibtex
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/mapping/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$output$2f$value$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/output/value.js [app-ssr] (ecmascript)");
;
;
function formatEntryValues({ type, label, properties }) {
    const output = {
        type,
        label,
        properties: {}
    };
    for(const property in properties){
        const value = properties[property];
        const [field, annotation] = property.split('+an:');
        if (annotation) {
            if (!output.annotations) {
                output.annotations = {};
            }
            if (!output.annotations[field]) {
                output.annotations[field] = {};
            }
            output.annotations[field][annotation] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$output$2f$value$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["formatAnnotation"])(value);
        } else {
            output.properties[property] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$output$2f$value$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(property, value);
        }
    }
    return output;
}
function format(entries) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(entries).map(formatEntryValues);
}
function formatBibtex(entries) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$mapping$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["formatBibtex"])(entries).map(formatEntryValues);
}
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/output/bibtex.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "format",
    ()=>format
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/config.js [app-ssr] (ecmascript)");
;
function formatField(field, value, dict) {
    return dict.listItem.join(`${field} = {${value}},`);
}
function formatEntry(entry, dict) {
    const fields = [];
    for(const field in entry.properties){
        fields.push(formatField(field, entry.properties[field], dict));
        if (entry.annotations && entry.annotations[field]) {
            for(const annotation in entry.annotations[field]){
                let annotationField = field + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].biber.annotationMarker;
                if (annotation !== 'default') {
                    annotationField += __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].biber.namedAnnotationMarker + annotation;
                }
                fields.push(formatField(annotationField, entry.annotations[field][annotation], dict));
            }
        }
    }
    return dict.entry.join(`@${entry.type}{${entry.label},${dict.list.join(fields.join(''))}}`);
}
function format(src, dict) {
    const entries = src.map((entry)=>formatEntry(entry, dict)).join('');
    return dict.bibliographyContainer.join(entries);
}
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/output/bibtxt.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "format",
    ()=>format
]);
function formatEntry({ type, label, properties }, dict) {
    const fields = Object.entries(properties).concat([
        [
            'type',
            type
        ]
    ]).map(([field, value])=>dict.listItem.join(`${field}: ${value}`));
    return dict.entry.join(`[${label}]${dict.list.join(fields.join(''))}`);
}
function format(src, dict) {
    const entries = src.map((entry)=>formatEntry(entry, dict)).join('\n');
    return dict.bibliographyContainer.join(entries);
}
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/output/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$core$2f$lib$2d$mjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/core/lib-mjs/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$core$2f$lib$2d$mjs$2f$plugins$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__plugins$3e$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/core/lib-mjs/plugins/index.js [app-ssr] (ecmascript) <export * as plugins>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$output$2f$entries$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/output/entries.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$output$2f$bibtex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/output/bibtex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$output$2f$bibtxt$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/output/bibtxt.js [app-ssr] (ecmascript)");
;
;
;
;
const factory = function(mapper, formatter) {
    return function(data, opts = {}) {
        const { type, format = type || 'text' } = opts;
        data = mapper(data);
        if (format === 'object') {
            return data;
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$core$2f$lib$2d$mjs$2f$plugins$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__plugins$3e$__["plugins"].dict.has(format)) {
            return formatter(data, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$core$2f$lib$2d$mjs$2f$plugins$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__plugins$3e$__["plugins"].dict.get(format), opts);
        } else {
            throw new RangeError(`Output dictionary "${format}" not available`);
        }
    };
};
const __TURBOPACK__default__export__ = {
    bibtex: factory(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$output$2f$entries$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["formatBibtex"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$output$2f$bibtex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"]),
    biblatex: factory(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$output$2f$entries$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$output$2f$bibtex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"]),
    bibtxt: factory(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$output$2f$entries$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["formatBibtex"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$output$2f$bibtxt$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])
};
}),
"[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$core$2f$lib$2d$mjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/core/lib-mjs/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$core$2f$lib$2d$mjs$2f$plugins$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__plugins$3e$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/core/lib-mjs/plugins/index.js [app-ssr] (ecmascript) <export * as plugins>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/input/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/config.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$output$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@citation-js/plugin-bibtex/lib-mjs/output/index.js [app-ssr] (ecmascript)");
;
;
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$core$2f$lib$2d$mjs$2f$plugins$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__plugins$3e$__["plugins"].add(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ref"], {
    input: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$input$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["formats"],
    output: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$output$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    config: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$citation$2d$js$2f$plugin$2d$bibtex$2f$lib$2d$mjs$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
});
}),
];

//# sourceMappingURL=node_modules_%40citation-js_plugin-bibtex_6980d28c._.js.map